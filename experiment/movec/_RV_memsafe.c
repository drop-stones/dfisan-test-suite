#include "_RV_memsafe.h"
#define MEMSAFE_ACTION
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for data structures.
//
//===----------------------------------------------------------------------===*/

/*Addresses of predefined status nodes with auto-deallocation.
  Their lifetime is the entire run of the program.*/
_RV_stat_node *_RV_function_sa;
_RV_stat_node *_RV_global_sa;
_RV_stat_node *_RV_static_sa;
_RV_stat_node *_RV_library_sa;

#include <stdio.h>

/*Count of memory safety errors.*/
size_t _RV_error_count = 0;

void _RV_global_clear_code();

/*Print the runtime error count.*/
void _RV_print_error_count()
{
  _RV_global_clear_code();
  if(_RV_error_count == 1)
    fprintf(stderr, "1 error generated.\n");
  if(_RV_error_count >  1)
    fprintf(stderr, "%lu errors generated.\n", _RV_error_count);
}
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for metadata.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- stat_node ------------------------------===*/
_RV_stat_node *_RV_stat_node_create(_RV_status stat, size_t count);
_RV_status     _RV_stat_node_get_stat(const _RV_stat_node *snda);
size_t           _RV_stat_node_get_count(const _RV_stat_node *snda);
unsigned         _RV_stat_node_dec(_RV_stat_node *snda);
void             _RV_stat_node_inc(_RV_stat_node *snda);
/*===----------------------------- pmd ------------------------------------===*/
_RV_pmd       *_RV_pmd_create(_RV_ptr_addr ptra, _RV_stat_node *snda,
                       _RV_status stat, const void *base, const void *bound);
_RV_pmd       *_RV_pmd_create_null(_RV_ptr_addr ptra);
void             _RV_pmd_free(_RV_pmd *pmd);
void             _RV_pmd_free_null_ptr(_RV_pmd *pmd);
unsigned         _RV_pmd_is_null(const _RV_pmd *pmd);
const void      *_RV_pmd_get_base(const _RV_pmd *pmd);
const void      *_RV_pmd_get_bound(const _RV_pmd *pmd);
_RV_stat_node *_RV_pmd_get_snda(const _RV_pmd *pmd);
_RV_status     _RV_pmd_get_stat(const _RV_pmd *pmd);
size_t           _RV_pmd_get_count(const _RV_pmd *pmd);
void             _RV_pmd_print(const _RV_pmd *pmd);
#if defined(_RV_use_ext_cas)
unsigned         _RV_pmd_is_regular(const _RV_pmd *pmd);
unsigned         _RV_pmd_is_dummy(const _RV_pmd *pmd);
#endif
void             _RV_pmd_set_base(_RV_pmd *pmd, const void *base);
void             _RV_pmd_set_bound(_RV_pmd *pmd, const void *bound);
void             _RV_pmd_dc_snda(_RV_pmd *pmd);
void             _RV_pmd_c_snda(_RV_pmd *pmd, _RV_stat_node *snda);
void             _RV_pmd_set_stat(_RV_pmd *pmd, _RV_status stat);
_RV_pmd       *_RV_pmd_set(_RV_pmd *pmd, _RV_stat_node *snda,
                       _RV_status stat, const void *base, const void *bound);
void            *_RV_pmd_set_ret(_RV_pmd *pmd, _RV_stat_node *snda,
                       _RV_status stat, const void *base, const void *bound, const void *ret);
void             _RV_pmd_set_null(_RV_pmd *pmd);
_RV_pmd       *_RV_pmd_cp_pmd(_RV_pmd *pmd, const _RV_pmd *pmd2);
void            *_RV_pmd_cp_pmd_ret(_RV_pmd *pmd, const _RV_pmd *pmd2, const void *ret);
_RV_pmd       *_RV_pmd_cp_fmd_pmd(_RV_pmd *pmd, const _RV_fmd_pmd *fpmd);
/*===----------------------------- fmd_pmd --------------------------------===*/
unsigned         _RV_fmd_pmd_is_null(const _RV_fmd_pmd *fpmd);
const void      *_RV_fmd_pmd_get_base(const _RV_fmd_pmd *fpmd);
const void      *_RV_fmd_pmd_get_bound(const _RV_fmd_pmd *fpmd);
_RV_stat_node *_RV_fmd_pmd_get_snda(const _RV_fmd_pmd *fpmd);
_RV_status     _RV_fmd_pmd_get_stat(const _RV_fmd_pmd *fpmd);
void             _RV_fmd_pmd_dc_snda(_RV_fmd_pmd *fpmd);
void             _RV_fmd_pmd_c_snda(_RV_fmd_pmd *fpmd, _RV_stat_node *snda);
void             _RV_fmd_pmd_set(_RV_fmd_pmd *fpmd, _RV_stat_node *snda,
                       _RV_status stat, const void *base, const void *bound);
void             _RV_fmd_pmd_set_null(_RV_fmd_pmd *fpmd);
void             _RV_fmd_pmd_cp_pmd(_RV_fmd_pmd *fpmd, const _RV_pmd *pmd);
/*===----------------------------- fmd ------------------------------------===*/
_RV_fmd     *_RV_fmd_create(_RV_func_addr func, unsigned char capacity);
void           _RV_fmd_free_pmds(_RV_fmd *fmd);
void           _RV_fmd_free(_RV_fmd *fmd);
_RV_fmd_pmd *_RV_fmd_get_fmd_pmd(const _RV_fmd *fmd, unsigned char i);
#if defined(_RV_use_ext_cas)
unsigned       _RV_fmd_is_regular(const _RV_fmd *fmd);
unsigned       _RV_fmd_is_dummy(const _RV_fmd *fmd);
#endif
void           _RV_fmd_dc_snda(_RV_fmd *fmd);
void           _RV_fmd_set_null(_RV_fmd *fmd);
void           _RV_fmd_cp_pmd(_RV_fmd *fmd, unsigned char i, const _RV_pmd *pmd);
void           _RV_fmd_resize_pmds(_RV_fmd *fmd, unsigned char new_capacity,
                     unsigned char clear);

/*===----------------------------- stat_node ------------------------------===*/

#include <stdlib.h>

/*Create a new status node.*/
 inline
_RV_stat_node *_RV_stat_node_create(_RV_status stat, size_t count)
{
  _RV_stat_node *snda = (_RV_stat_node *)malloc(sizeof(_RV_stat_node));
  if(snda == NULL) return NULL;
  snda->stat  = stat;
  snda->count = count;
  return snda;
}

 inline
_RV_status _RV_stat_node_get_stat(const _RV_stat_node *snda)
{
  if(snda == NULL) return _RV_invalid;
  return snda->stat;
}

 inline
size_t _RV_stat_node_get_count(const _RV_stat_node *snda)
{
  if(snda == NULL) return 0;
  return snda->count;
}

/*Decrease the count of a status node. If the count becomes 0, it is freed.
  If there is a memory leak, then it returns 1. Otherwise, it returns 0.*/
 inline
unsigned _RV_stat_node_dec(_RV_stat_node *snda)
{
  unsigned ret = 0;
  if(snda == NULL)
    return 0;
  if(snda->count == 0)
    return 0;
  if(snda->count == 1)
  {
    if(snda->stat == _RV_heap) ret = 1;
    free(snda);
  }
  else
    snda->count--;
  return ret;
}

/*Increase the count of a status node.*/
 inline
void _RV_stat_node_inc(_RV_stat_node *snda)
{
  if(snda == NULL) return;
  snda->count++;
}

/*===----------------------------- pmd ------------------------------------===*/

#if defined(_RV_use_ext_cas)
void            _RV_freelist_insert_pmd(_RV_pmd *pmd);
void            _RV_freelist_insert_fmd(_RV_fmd *fmd);
_RV_so_key_t  _RV_so_regularkey(const void *p);
_RV_so_key_t  _RV_so_dummykey(size_t index);
#endif

/*Create a new pointer metadata.
  If snda is NULL, then a new status node is created from stat.
  If stat is invalid, then its snda is set to NULL.*/
 inline
_RV_pmd *_RV_pmd_create(_RV_ptr_addr ptra, _RV_stat_node *snda,
                 _RV_status stat, const void *base, const void *bound)
{
  _RV_pmd *pmd = (_RV_pmd *)malloc(sizeof(_RV_pmd));
  if(pmd == NULL) return NULL;
  pmd->snda = NULL;
  _RV_pmd_set(pmd, snda, stat, base, bound);
#if defined(_RV_use_trie)
  if(ptra == NULL) pmd->pmdflag = 2;
  else pmd->pmdflag = 1;
#elif defined(_RV_use_hashtable)
  pmd->ptra = ptra;
  pmd->next = NULL;
#if defined(_RV_use_ext_cas)
  pmd->so_key = _RV_so_regularkey(ptra);
#endif
#endif
  return pmd;
}

/*Create a new pointer metadata whose snda, base, bound and next are NULL.*/
 inline
_RV_pmd *_RV_pmd_create_null(_RV_ptr_addr ptra)
{
  _RV_pmd *pmd = (_RV_pmd *)malloc(sizeof(_RV_pmd));
  if(pmd == NULL) return NULL;
  pmd->snda  = NULL;
  pmd->base  = NULL;
  pmd->bound = NULL;
#if defined(_RV_use_trie)
  if(ptra == NULL) pmd->pmdflag = 2;
  else pmd->pmdflag = 1;
#elif defined(_RV_use_hashtable)
  pmd->ptra = ptra;
  pmd->next = NULL;
#if defined(_RV_use_ext_cas)
  pmd->so_key = _RV_so_regularkey(ptra);
#endif
#endif
  return pmd;
}

/*Free a pointer metadata.*/
 inline
void _RV_pmd_free(_RV_pmd *pmd)
{
  if(pmd == NULL) return;
  _RV_pmd_dc_snda(pmd);
#if defined(_RV_use_ext_cas)
  _RV_freelist_insert_pmd(pmd);
#else
  free(pmd);
#endif
}

/*Free a pointer metadata only if its member "ptra" is NULL.*/
 inline
void _RV_pmd_free_null_ptr(_RV_pmd *pmd)
{
  if(pmd == NULL) return;
#if defined(_RV_use_trie)
  if(pmd->pmdflag == 2)
    _RV_pmd_free(pmd);
#elif defined(_RV_use_hashtable)
  if(pmd->ptra == NULL)
    _RV_pmd_free(pmd);
#endif
}

 inline
unsigned _RV_pmd_is_null(const _RV_pmd *pmd)
{
  if(pmd == NULL) return 1;
  if(pmd->snda == NULL && pmd->base == NULL && pmd->bound == NULL)
    return 1;
  return 0;
}

 inline
const void *_RV_pmd_get_base(const _RV_pmd *pmd)
{
  if(pmd == NULL) return NULL;
  return pmd->base;
}

 inline
const void *_RV_pmd_get_bound(const _RV_pmd *pmd)
{
  if(pmd == NULL) return NULL;
  return pmd->bound;
}

 inline
_RV_stat_node *_RV_pmd_get_snda(const _RV_pmd *pmd)
{
  if(pmd == NULL) return NULL;
  return pmd->snda;
}

 inline
_RV_status _RV_pmd_get_stat(const _RV_pmd *pmd)
{
  if(pmd == NULL) return _RV_invalid;
  return _RV_stat_node_get_stat(pmd->snda);
}

 inline
size_t _RV_pmd_get_count(const _RV_pmd *pmd)
{
  if(pmd == NULL) return 0;
  return _RV_stat_node_get_count(pmd->snda);
}

/*Print a pmd.*/
 inline
void _RV_pmd_print(const _RV_pmd *pmd)
{
  if(!pmd)
    printf("The pmd does not exist.\n");
  else
  {
    printf("The pmd is [%p, %p), status = ",
           pmd->base, pmd->bound);
    if(!pmd->snda)
      printf("(null)\n");
    else
      printf("(%d, %lu)\n", pmd->snda->stat, pmd->snda->count);
  }
}

#if defined(_RV_use_ext_cas)
/*Decide if a pmd is a regular node, i.e., whether the LSB of its so_key is 1.*/
 inline
unsigned _RV_pmd_is_regular(const _RV_pmd *pmd)
{
  if(pmd == NULL) return 0;
  return pmd->so_key & 1;
}

/*Decide if a pmd is a dummy node, i.e., whether the LSB of its so_key is 0.*/
 inline
unsigned _RV_pmd_is_dummy(const _RV_pmd *pmd)
{
  if(pmd == NULL) return 0;
  return (pmd->so_key & 1) == 0;
}
#endif

/*Set the base of a pointer metadata.
  If pmd does not exist, do nothing.*/
 inline
void _RV_pmd_set_base(_RV_pmd *pmd, const void *base)
{
  if(pmd == NULL) return;
  pmd->base = base;
}

/*Set the bound of a pointer metadata.
  If pmd does not exist, do nothing.*/
 inline
void _RV_pmd_set_bound(_RV_pmd *pmd, const void *bound)
{
  if(pmd == NULL) return;
  pmd->bound = bound;
}

/*Disconnect a pointer metadata from its status node.*/
 inline
void _RV_pmd_dc_snda(_RV_pmd *pmd)
{
  if(pmd == NULL) return;

  /*check memory leaks.*/
  if(_RV_stat_node_dec(pmd->snda) == 1)
  {
#if !defined(_RV_MSNOCHECK)
#if defined(_RV_NORANDOM)
    fprintf(stderr, "error: memory leak detected.\n");
#else
#if defined(_RV_use_trie)
    fprintf(stderr, "error: memory leak of the block [%p, %p).\n",
            pmd->base, pmd->bound);
#elif defined(_RV_use_hashtable)
    fprintf(stderr, "error: memory leak of the block [%p, %p), "
            "the last pointer's address is %p.\n",
            pmd->base, pmd->bound, pmd->ptra);
#endif
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
#endif
  }

  pmd->snda = NULL;
}

/*Connect a pointer metadata to a given status node.*/
 inline
void _RV_pmd_c_snda(_RV_pmd *pmd, _RV_stat_node *snda)
{
  if(pmd == NULL || pmd->snda == snda) return;
  _RV_pmd_dc_snda(pmd);
  pmd->snda = snda;
  _RV_stat_node_inc(snda);
}

/*Set the stat of a pointer metadata.
  If pmd->snda does not exist, do nothing.*/
 inline
void _RV_pmd_set_stat(_RV_pmd *pmd, _RV_status stat)
{
  if(pmd == NULL || pmd->snda == NULL) return;
  pmd->snda->stat = stat;
}

/*Set the snda, base and bound of a pointer metadata.
  If snda is NULL, then a new status node is created from stat.
  If stat is invalid, then its snda is set to NULL.*/
 inline
_RV_pmd *_RV_pmd_set(_RV_pmd *pmd, _RV_stat_node *snda,
        _RV_status stat, const void *base, const void *bound)
{
  if(pmd == NULL) return pmd;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  /*set status*/
  if(snda != NULL)
    _RV_pmd_c_snda(pmd, snda);
  else
  {
    _RV_pmd_dc_snda(pmd);
    if(stat != _RV_invalid)
      pmd->snda = _RV_stat_node_create(stat, 1);
  }
  /*set base and bound*/
  pmd->base  = base;
  pmd->bound = bound;
#if defined(_RV_use_trie)
  pmd->pmdflag = 1;
#endif
  return pmd;
}

 inline
void *_RV_pmd_set_ret(_RV_pmd *pmd, _RV_stat_node *snda,
        _RV_status stat, const void *base, const void *bound, const void *ret)
{
  _RV_pmd_set(pmd, snda, stat, base, bound);
  return (void *)ret;
}

/*Set the snda, base and bound of a pointer metadata to NULL.*/
 inline
void _RV_pmd_set_null(_RV_pmd *pmd)
{
  if(pmd == NULL) return;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  _RV_pmd_dc_snda(pmd);
  pmd->base  = NULL;
  pmd->bound = NULL;
#if defined(_RV_use_trie)
  pmd->pmdflag = 1;
#endif
}

/*Copy the snda, base and bound from a pmd.*/
 inline
_RV_pmd *_RV_pmd_cp_pmd(_RV_pmd *pmd, const _RV_pmd *pmd2)
{
  if(pmd == NULL) return pmd;
  if(pmd2 == NULL)
    _RV_pmd_set_null(pmd);
  else
  {
    /* Note: To report base and bound for memory leak,
       snda must be set before setting base and bound. */
    _RV_pmd_c_snda(pmd, pmd2->snda);
    pmd->base  = pmd2->base;
    pmd->bound = pmd2->bound;
#if defined(_RV_use_trie)
    pmd->pmdflag = 1;
#endif
  }
  return pmd;
}

 inline
void *_RV_pmd_cp_pmd_ret(_RV_pmd *pmd, const _RV_pmd *pmd2, const void *ret)
{
  _RV_pmd_cp_pmd(pmd, pmd2);
  return (void *)ret;
}

/*Copy the snda, base and bound from a pmd in function pointer metadata.*/
 inline
_RV_pmd *_RV_pmd_cp_fmd_pmd(_RV_pmd *pmd, const _RV_fmd_pmd *fpmd)
{
  if(pmd == NULL) return pmd;
  if(fpmd == NULL)
    _RV_pmd_set_null(pmd);
  else
  {
    /* Note: To report base and bound for memory leak,
       snda must be set before setting base and bound. */
    _RV_pmd_c_snda(pmd, fpmd->snda);
    pmd->base  = fpmd->base;
    pmd->bound = fpmd->bound;
#if defined(_RV_use_trie)
    pmd->pmdflag = 1;
#endif
  }
  return pmd;
}

/*===----------------------------- fmd_pmd --------------------------------===*/

 inline
unsigned _RV_fmd_pmd_is_null(const _RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return 1;
  if(fpmd->snda == NULL && fpmd->base == NULL && fpmd->bound == NULL)
    return 1;
  return 0;
}

 inline
const void *_RV_fmd_pmd_get_base(const _RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return NULL;
  return fpmd->base;
}

 inline
const void *_RV_fmd_pmd_get_bound(const _RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return NULL;
  return fpmd->bound;
}

 inline
_RV_stat_node *_RV_fmd_pmd_get_snda(const _RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return NULL;
  return fpmd->snda;
}

 inline
_RV_status _RV_fmd_pmd_get_stat(const _RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return _RV_invalid;
  return _RV_stat_node_get_stat(fpmd->snda);
}

/*Disconnect a pmd in function pointer metadata from its status node.*/
 inline
void _RV_fmd_pmd_dc_snda(_RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return;

  /*check memory leaks.*/
  if(_RV_stat_node_dec(fpmd->snda) == 1)
  {
#if !defined(_RV_MSNOCHECK)
#if defined(_RV_NORANDOM)
    fprintf(stderr, "error: memory leak detected.\n");
#else
    fprintf(stderr, "error: memory leak of the block [%p, %p), "
            "the last pointer is a function parameter.\n",
            fpmd->base, fpmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
#endif
  }

  fpmd->snda = NULL;
}

/*Connect a pmd in function pointer metadata to a given status node.*/
 inline
void _RV_fmd_pmd_c_snda(_RV_fmd_pmd *fpmd, _RV_stat_node *snda)
{
  if(fpmd == NULL || fpmd->snda == snda) return;
  _RV_fmd_pmd_dc_snda(fpmd);
  fpmd->snda = snda;
  _RV_stat_node_inc(snda);
}

/*Set the snda, base and bound of a pmd in function pointer metadata.
  If snda is NULL, then a new status node is created from stat.
  If stat is invalid, then its snda is set to NULL.*/
 inline
void _RV_fmd_pmd_set(_RV_fmd_pmd *fpmd, _RV_stat_node *snda,
                       _RV_status stat, const void *base, const void *bound)
{
  if(fpmd == NULL) return;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  /*set status*/
  if(snda != NULL)
    _RV_fmd_pmd_c_snda(fpmd, snda);
  else
  {
    _RV_fmd_pmd_dc_snda(fpmd);
    if(stat != _RV_invalid)
      fpmd->snda = _RV_stat_node_create(stat, 1);
  }
  /*set base and bound*/
  fpmd->base  = base;
  fpmd->bound = bound;
}

/*Set the snda, base and bound of a pmd in function pointer metadata to NULL.*/
 inline
void _RV_fmd_pmd_set_null(_RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  _RV_fmd_pmd_dc_snda(fpmd);
  fpmd->base  = NULL;
  fpmd->bound = NULL;
}

/*Copy the snda, base and bound from a pointer metadata.*/
 inline
void _RV_fmd_pmd_cp_pmd(_RV_fmd_pmd *fpmd, const _RV_pmd *pmd)
{
  if(fpmd == NULL) return;
  if(pmd == NULL)
    _RV_fmd_pmd_set_null(fpmd);
  else
  {
    /* Note: To report base and bound for memory leak,
       snda must be set before setting base and bound. */
    _RV_fmd_pmd_c_snda(fpmd, pmd->snda);
    fpmd->base  = pmd->base;
    fpmd->bound = pmd->bound;
  }
}

/*===----------------------------- fmd ------------------------------------===*/

/*Create a function pointer metadata with the given capacity.*/

_RV_fmd *_RV_fmd_create(_RV_func_addr func, unsigned char capacity)
{
  _RV_fmd *fmd = (_RV_fmd *)malloc(sizeof(_RV_fmd));
  unsigned char i;

  if(fmd == NULL) return NULL;

  fmd->pmds = (_RV_fmd_pmd *)malloc(capacity*sizeof(_RV_fmd_pmd));
  if(fmd->pmds == NULL)
  {
    free(fmd);
    return NULL;
  }
  for(i = 0; i < capacity; i++)
  {
    fmd->pmds[i].base  = NULL;
    fmd->pmds[i].bound = NULL;
    fmd->pmds[i].snda  = NULL;
  }
  fmd->capacity = capacity;
  fmd->func = func;
  fmd->next = NULL;
#if defined(_RV_use_ext_cas)
  fmd->so_key = _RV_so_regularkey(func);
#endif
  return fmd;
}

/*Free all the pointer metadata in a function pointer metadata.*/

void _RV_fmd_free_pmds(_RV_fmd *fmd)
{
  unsigned char i;
  if(fmd == NULL || fmd->pmds == NULL) return;
  for(i = 0; i < fmd->capacity; i++)
    _RV_fmd_pmd_dc_snda(fmd->pmds + i);
  free(fmd->pmds);
  fmd->pmds = NULL;
  fmd->capacity = 0;
}

/*Free a function pointer metadata.*/
 inline
void _RV_fmd_free(_RV_fmd *fmd)
{
  if(fmd == NULL) return;
  _RV_fmd_free_pmds(fmd);
#if defined(_RV_use_ext_cas)
  _RV_freelist_insert_fmd(fmd);
#else
  free(fmd);
#endif
}

/*Get the i-th pointer metadata in a function pointer metadata.*/
 inline
_RV_fmd_pmd *_RV_fmd_get_fmd_pmd(const _RV_fmd *fmd, unsigned char i)
{
  if(fmd == NULL || fmd->pmds == NULL || i >= fmd->capacity)
    return NULL;
  return fmd->pmds + i;
}

#if defined(_RV_use_ext_cas)
/*Decide if a fmd is a regular node, i.e., whether the LSB of its so_key is 1.*/
 inline
unsigned _RV_fmd_is_regular(const _RV_fmd *fmd)
{
  if(fmd == NULL) return 0;
  return fmd->so_key & 1;
}

/*Decide if a fmd is a dummy node, i.e., whether the LSB of its so_key is 0.*/
 inline
unsigned _RV_fmd_is_dummy(const _RV_fmd *fmd)
{
  if(fmd == NULL) return 0;
  return (fmd->so_key & 1) == 0;
}
#endif

/*Disconnect all pmds in function pointer metadata from their status nodes.*/

void _RV_fmd_dc_snda(_RV_fmd *fmd)
{
  unsigned char i;
  if(fmd == NULL || fmd->pmds == NULL) return;
  for(i = 0; i < fmd->capacity; i++)
    _RV_fmd_pmd_dc_snda(fmd->pmds + i);
}

/*Set the snda, base and bound of all pmds in function pointer metadata to NULL.*/
 inline
void _RV_fmd_set_null(_RV_fmd *fmd)
{
  unsigned char i;
  if(fmd == NULL || fmd->pmds == NULL) return;
  for(i = 0; i < fmd->capacity; i++)
    _RV_fmd_pmd_set_null(fmd->pmds + i);
}

/*Copy the snda, base and bound from a pointer metadata,
  to the i-th pointer metadata in a function pointer metadata.*/
 inline
void _RV_fmd_cp_pmd(_RV_fmd *fmd, unsigned char i, const _RV_pmd *pmd)
{
  _RV_fmd_pmd_cp_pmd(_RV_fmd_get_fmd_pmd(fmd, i), pmd);
}

/*Resize the table of pmds in a function pointer metadata to a new capacity.
  If clear is 0, then the old pointer metadata will not be cleared,
  i.e., reused by the new table of pointer metadata.*/

void _RV_fmd_resize_pmds(_RV_fmd *fmd, unsigned char new_capacity,
                           unsigned char clear)
{
  unsigned char i;
  _RV_fmd_pmd *new_pmds;
  if(fmd->capacity >= new_capacity) /*decrease capacity, reuse old pmds*/
  {
    if(clear != 0)
      for(i = 0; i < new_capacity; i++)
        _RV_fmd_pmd_set_null(fmd->pmds + i);
    for(i = new_capacity; i < fmd->capacity; i++)
      _RV_fmd_pmd_set_null(fmd->pmds + i);
  }
  else /*fmd->capacity < new_capacity, i.e., increase capacity*/
  {
    new_pmds = (_RV_fmd_pmd *)malloc(new_capacity*sizeof(_RV_fmd_pmd));
    if(clear != 0)
    {
      for(i = 0; i < new_capacity; i++)
      {
        new_pmds[i].base  = NULL;
        new_pmds[i].bound = NULL;
        new_pmds[i].snda  = NULL;
      }
    }
    else /*do not clear, i.e., reuse old pmds*/
    {
      for(i = 0; i < fmd->capacity; i++)
      {
        new_pmds[i].base  = fmd->pmds[i].base;
        new_pmds[i].bound = fmd->pmds[i].bound;
        new_pmds[i].snda  = fmd->pmds[i].snda;
      }
      for(     ; i < new_capacity; i++)
      {
        new_pmds[i].base  = NULL;
        new_pmds[i].bound = NULL;
        new_pmds[i].snda  = NULL;
      }
    }
    free(fmd->pmds);
    fmd->pmds = new_pmds;
    fmd->capacity = new_capacity;
  } /* end if(fmd->capacity < new_capacity) */
}
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for tries.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- trie -----------------------------------===*/
void         _RV_trie_get_index(_RV_ptr_addr ptra,
                   size_t *primary_index, size_t *secondary_index);
_RV_pmd  **_RV_trie_create();
_RV_pmd   *_RV_trie_create_secondary();
_RV_pmd   *_RV_trie_find_pmd(_RV_pmd **tbl, _RV_ptr_addr ptra);
_RV_pmd   *_RV_trie_insert_pmd_ptr(_RV_pmd **tbl, _RV_ptr_addr ptra);
int          _RV_trie_remove_pmd(_RV_pmd **tbl, _RV_ptr_addr ptra);
_RV_pmd ***_RV_trie_get_trie_ref_pmd();
_RV_pmd  **_RV_trie_get_trie_pmd();

/*===----------------------------- trie -----------------------------------===*/

#if defined(_DEFAULT_SOURCE)
#include <sys/mman.h>
#else
#include <stdlib.h>
#endif
#include <assert.h>

/* The primary table has 2^23 entries. */
const size_t _RV_TRIE_PRIMARY_ENTRIES = 0x800000;
/* Each secondary table has 2^22 entries. */
const size_t _RV_TRIE_SECONDARY_ENTRIES = 0x400000;
#if defined(_DEFAULT_SOURCE)
#if defined(__APPLE__)
#define _RV_TRIE_MMAP_FLAGS (MAP_ANON|MAP_NORESERVE|MAP_PRIVATE)
#else
#define _RV_TRIE_MMAP_FLAGS (MAP_ANONYMOUS|MAP_NORESERVE|MAP_PRIVATE)
#endif
#endif

/*Get the primary and secondary indices of a pointer address in a trie.*/
 inline
void _RV_trie_get_index(_RV_ptr_addr ptra,
           size_t *primary_index, size_t *secondary_index)
{
  size_t key = (size_t) ptra;
  *primary_index = ((key >> 25) & 0x7fffff);
  *secondary_index = ((key >> 3) & 0x3fffff);
}

 inline
_RV_pmd **_RV_trie_create()
{
  size_t len = _RV_TRIE_PRIMARY_ENTRIES * sizeof(_RV_pmd *);
#if defined(_DEFAULT_SOURCE)
  _RV_pmd **trie_primary =
    mmap(0, len, PROT_READ|PROT_WRITE, _RV_TRIE_MMAP_FLAGS, -1, 0);
  assert(trie_primary != (void *)-1);
#else
  _RV_pmd **trie_primary = malloc(len);
  assert(trie_primary != NULL);
#endif
  return trie_primary;
}

 inline
_RV_pmd *_RV_trie_create_secondary()
{
  size_t len = _RV_TRIE_SECONDARY_ENTRIES * sizeof(_RV_pmd);
#if defined(_DEFAULT_SOURCE)
  _RV_pmd *trie_secondary =
    mmap(0, len, PROT_READ|PROT_WRITE, _RV_TRIE_MMAP_FLAGS, -1, 0);
  assert(trie_secondary != (void*)-1);
#else
  _RV_pmd *trie_secondary = malloc(len);
  assert(trie_secondary != NULL);
#endif
  return trie_secondary;
}

/*Find the pmd of the given pointer address in the trie.
  If the pmd does not exist, it returns NULL.*/
 inline
_RV_pmd *_RV_trie_find_pmd(_RV_pmd **tbl, _RV_ptr_addr ptra)
{
  size_t primary_index;
  size_t secondary_index;
  _RV_pmd *secondary_table;

  _RV_trie_get_index(ptra, &primary_index, &secondary_index);
  secondary_table = tbl[primary_index];
  if(secondary_table == NULL) return NULL;
  if(secondary_table[secondary_index].pmdflag == 0) return NULL;
  return secondary_table + secondary_index;
}

/*Insert a pmd of the given pointer address to the trie.
  If the pmd of the given pointer address already exists,
  the existing pmd will be returned.*/
 inline
_RV_pmd *_RV_trie_insert_pmd_ptr(_RV_pmd **tbl, _RV_ptr_addr ptra)
{
  size_t primary_index;
  size_t secondary_index;
  _RV_pmd *secondary_table;

  _RV_trie_get_index(ptra, &primary_index, &secondary_index);
  secondary_table = tbl[primary_index];
  if(secondary_table == NULL)
  {
    secondary_table = _RV_trie_create_secondary();
    tbl[primary_index] = secondary_table;
  }
  secondary_table[secondary_index].pmdflag = 1;
  return secondary_table + secondary_index;
}

/*Remove (set null) the pmd of the given pointer address from the trie.
  If a pmd is removed (set null), it returns 1. Otherwise, it returns 0.*/
 inline
int _RV_trie_remove_pmd(_RV_pmd **tbl, _RV_ptr_addr ptra)
{
  _RV_pmd *pmd = _RV_trie_find_pmd(tbl, ptra);
  /*not found*/
  if(NULL == pmd)
    return 0;
  /*found: set the existing pmd to NULL*/
  _RV_pmd_set_null(pmd);
  pmd->pmdflag = 0;
  return 1;
}

/*Get the reference of the trie storing pmds.
  If it does not exist, an empty trie will be created and returned.*/

_RV_pmd ***_RV_trie_get_trie_ref_pmd()
{
  static _RV_pmd **tbl = NULL;
  if(NULL == tbl)
    tbl = _RV_trie_create();
  return &tbl;
}

/*Get the trie storing pmds.
  If it does not exist, an empty trie will be created and returned.*/
 inline
_RV_pmd **_RV_trie_get_trie_pmd()
{
  return *_RV_trie_get_trie_ref_pmd();
}
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for hash tables.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- list -----------------------------------===*/
#if defined(_RV_use_hashtable)
int _RV_list_find_pmd_ref(_RV_pmd **head_ref, _RV_ptr_addr ptra,
               _RV_pmd ***prev_ref);
int _RV_list_insert_pmd(_RV_pmd **head_ref, _RV_pmd *pmd,
               _RV_pmd ***prev_ref);
int _RV_list_insert_pmd_ptr(_RV_pmd **head_ref, _RV_ptr_addr ptra,
               _RV_pmd ***prev_ref);
int _RV_list_remove_pmd(_RV_pmd **head_ref, _RV_ptr_addr ptra,
               _RV_pmd ***prev_ref);
#endif
int _RV_list_find_fmd_ref(_RV_fmd **head_ref, _RV_func_addr func,
               _RV_fmd ***prev_ref);
int _RV_list_insert_fmd(_RV_fmd **head_ref, _RV_fmd *fmd,
               _RV_fmd ***prev_ref);
int _RV_list_insert_fmd_func(_RV_fmd **head_ref, _RV_func_addr func,
               unsigned char capacity, _RV_fmd ***prev_ref);
int _RV_list_remove_fmd(_RV_fmd **head_ref, _RV_func_addr func,
               _RV_fmd ***prev_ref);
/*===----------------------------- hashtbl --------------------------------===*/
size_t          _RV_hashtbl_hash(size_t key, size_t capacity);
_RV_hashtbl  *_RV_hashtbl_create(size_t capacity);
/*===----------------------------- hashtbl for pmd ------------------------===*/
#if defined(_RV_use_hashtable)
void            _RV_hashtbl_free_slots_pmd(_RV_hashtbl *tbl);
void            _RV_hashtbl_free_pmd(_RV_hashtbl *tbl);
_RV_pmd      *_RV_hashtbl_find_pmd(_RV_hashtbl *tbl, _RV_ptr_addr ptra);
_RV_pmd      *_RV_hashtbl_insert_pmd(_RV_hashtbl *tbl, _RV_pmd *pmd);
_RV_pmd      *_RV_hashtbl_insert_pmd_ptr(_RV_hashtbl *tbl, _RV_ptr_addr ptra);
int             _RV_hashtbl_remove_pmd(_RV_hashtbl *tbl, _RV_ptr_addr ptra);
void            _RV_hashtbl_resize_pmd(_RV_hashtbl *tbl);
_RV_hashtbl  *_RV_hashtbl_transfer_pmds(_RV_hashtbl *old_tbl, _RV_hashtbl *new_tbl);
_RV_hashtbl **_RV_hashtbl_get_hashtbl_ref_pmd();
_RV_hashtbl  *_RV_hashtbl_get_hashtbl_pmd();
#endif
/*===----------------------------- hashtbl for fmd ------------------------===*/
void            _RV_hashtbl_free_slots_fmd(_RV_hashtbl *tbl);
void            _RV_hashtbl_free_fmd(_RV_hashtbl *tbl);
_RV_fmd      *_RV_hashtbl_find_fmd(_RV_hashtbl *tbl, _RV_func_addr func);
_RV_fmd      *_RV_hashtbl_insert_fmd(_RV_hashtbl *tbl, _RV_fmd *fmd);
_RV_fmd      *_RV_hashtbl_insert_fmd_func(_RV_hashtbl *tbl, _RV_func_addr func, unsigned char capacity);
int             _RV_hashtbl_remove_fmd(_RV_hashtbl *tbl, _RV_func_addr func);
void            _RV_hashtbl_resize_fmd(_RV_hashtbl *tbl);
_RV_hashtbl  *_RV_hashtbl_transfer_fmds(_RV_hashtbl *old_tbl, _RV_hashtbl *new_tbl);
_RV_hashtbl **_RV_hashtbl_get_hashtbl_ref_fmd();
_RV_hashtbl  *_RV_hashtbl_get_hashtbl_fmd();
#if defined(_RV_use_one_fmd)
/*Note that the hash table of fmd should not be replaced by an fmd buffer.
  For example, in a variadic function, the statements that get parameter values
  may be mixed with some function calls, thus the fmd buffer could be rewritten
  by these calls before finished reading the pmds of parameters. As a result,
  the pmds of parameters gotten after these calls are incorrect,
  and may lead to false positives or negatives.*/
_RV_fmd     **_RV_fmd_get_fmd_ref();
_RV_fmd      *_RV_fmd_get_fmd();
#endif

/*===----------------------------- list -----------------------------------===*/

#if defined(_RV_use_hashtable)

/*Find the pmd of the given pointer address in the linked list.
  If the pmd exists, it returns 1. Otherwise, it returns 0.
  The third parameter returns by pointer the address of the previous node's
  next pointer, after which the given pointer address could be inserted.*/

int _RV_list_find_pmd_ref(_RV_pmd **head_ref, _RV_ptr_addr ptra,
                            _RV_pmd ***prev_ref)
{
  _RV_pmd *cur;

  *prev_ref = head_ref;
  cur = **prev_ref;
  while(1)
  {
    if(cur == NULL)
      return 0;
    if(cur->ptra >= ptra)
      return cur->ptra == ptra;
    *prev_ref = &cur->next;
    cur = cur->next;
  }
}

/*Insert the given pmd to the linked list.
  If the pmd of the given pointer address already exists, it returns 0, and
  the existing pmd will be replaced and freed. Otherwise, it returns 1.*/
 inline
int _RV_list_insert_pmd(_RV_pmd **head_ref, _RV_pmd *pmd,
                          _RV_pmd ***prev_ref)
{
  _RV_pmd *cur;

  /*found: replace and free the existing pmd*/
  if(_RV_list_find_pmd_ref(head_ref, pmd->ptra, prev_ref))
  {
    cur = **prev_ref;
    pmd->next = cur->next;
    **prev_ref = pmd;
    _RV_pmd_free(cur);
    return 0;
  }
  /*not found: insert pmd*/
  pmd->next = **prev_ref;
  **prev_ref = pmd;
  return 1;
}

/*Insert a pmd of the given pointer address to the linked list.
  If the pmd of the given pointer address already exists, it returns 0.
  Otherwise, it returns 1. The third parameter returns by pointer
  the address of the previous node's next pointer.*/
 inline
int _RV_list_insert_pmd_ptr(_RV_pmd **head_ref, _RV_ptr_addr ptra,
                              _RV_pmd ***prev_ref)
{
  _RV_pmd *pmd;

  /*found: return 0*/
  if(_RV_list_find_pmd_ref(head_ref, ptra, prev_ref))
    return 0;
  /*not found: insert pmd*/
  pmd = _RV_pmd_create_null(ptra);
  pmd->next = **prev_ref;
  **prev_ref = pmd;
  return 1;
}

/*Remove and free the pmd of the given pointer address from the linked list.
  If a pmd is removed and freed, it returns 1. Otherwise, it returns 0.
  The third parameter returns by pointer the address of the previous node's
  next pointer.*/
 inline
int _RV_list_remove_pmd(_RV_pmd **head_ref, _RV_ptr_addr ptra,
                          _RV_pmd ***prev_ref)
{
  _RV_pmd *cur;

  /*not found: return 0*/
  if(!_RV_list_find_pmd_ref(head_ref, ptra, prev_ref))
    return 0;
  /*found: remove the existing pmd*/
  cur = **prev_ref;
  **prev_ref = cur->next;
  _RV_pmd_free(cur);
  return 1;
}

#endif


int _RV_list_find_fmd_ref(_RV_fmd **head_ref, _RV_func_addr func,
                            _RV_fmd ***prev_ref)
{
  _RV_fmd *cur;

  *prev_ref = head_ref;
  cur = **prev_ref;
  while(1)
  {
    if(cur == NULL)
      return 0;
    if(cur->func >= func)
      return cur->func == func;
    *prev_ref = &cur->next;
    cur = cur->next;
  }
}

 inline
int _RV_list_insert_fmd(_RV_fmd **head_ref, _RV_fmd *fmd,
                          _RV_fmd ***prev_ref)
{
  _RV_fmd *cur;

  /*found: replace and free the existing fmd*/
  if(_RV_list_find_fmd_ref(head_ref, fmd->func, prev_ref))
  {
    cur = **prev_ref;
    fmd->next = cur->next;
    **prev_ref = fmd;
    _RV_fmd_free(cur);
    return 0;
  }
  /*not found: insert fmd*/
  fmd->next = **prev_ref;
  **prev_ref = fmd;
  return 1;
}

 inline
int _RV_list_insert_fmd_func(_RV_fmd **head_ref, _RV_func_addr func,
                               unsigned char capacity, _RV_fmd ***prev_ref)
{
  _RV_fmd *fmd;

  /*found: return 0*/
  if(_RV_list_find_fmd_ref(head_ref, func, prev_ref))
  {
    _RV_fmd_resize_pmds(**prev_ref, capacity, 0);
    return 0;
  }
  /*not found: insert fmd*/
  fmd = _RV_fmd_create(func, capacity);
  fmd->next = **prev_ref;
  **prev_ref = fmd;
  return 1;
}

 inline
int _RV_list_remove_fmd(_RV_fmd **head_ref, _RV_func_addr func,
                          _RV_fmd ***prev_ref)
{
  _RV_fmd *cur;

  /*not found: return 0*/
  if(!_RV_list_find_fmd_ref(head_ref, func, prev_ref))
    return 0;
  /*found: remove the existing fmd*/
  cur = **prev_ref;
  **prev_ref = cur->next;
  _RV_fmd_free(cur);
  return 1;
}

/*===----------------------------- hashtbl --------------------------------===*/

/*Implement hash function hash_value = hash(key), where
  hash_value is used as the slot index of the key.*/
 inline
size_t _RV_hashtbl_hash(size_t key, size_t capacity)
{
  /*This function ensures that hashCodes that differ only by
    constant multiples at each bit position have a bounded
    number of collisions (approximately 8 at default load factor).*/
  key = key ^ (key >> 20) ^ (key >> 12);
  key = key ^ (key >>  7) ^ (key >>  4);
  return key & (capacity - 1);
}

/*Create a hash table of the given capacity.*/

_RV_hashtbl *_RV_hashtbl_create(size_t capacity)
{
  size_t i;
  _RV_hashtbl *tbl = (_RV_hashtbl*)malloc(sizeof(_RV_hashtbl));
  if(NULL == tbl) return NULL;

  tbl->slots = (void **)malloc(capacity*sizeof(void *));
  if(NULL == tbl->slots)
  {
    free(tbl);
    return NULL;
  }

  for(i = 0; i < capacity; i++)
    tbl->slots[i] = NULL;
  tbl->capacity = capacity;
  tbl->size     = 0;
  tbl->count    = 0;
  return tbl;
}

/*===----------------------------- hashtbl for pmd ------------------------===*/

#if defined(_RV_use_hashtable)

/*Free the slots of a hash table storing pmds.*/

void _RV_hashtbl_free_slots_pmd(_RV_hashtbl *tbl)
{
  size_t i;
  _RV_pmd *pmd, *pmd1;
  if(tbl == NULL || tbl->slots == NULL) return;
  for(i = 0; i < tbl->capacity; i++)
  {
    pmd = (_RV_pmd *)tbl->slots[i];
    while(pmd != NULL)
    {
      pmd1 = pmd->next;
      _RV_pmd_free(pmd);
      pmd = pmd1;
    }
  }
  free(tbl->slots);
  tbl->slots    = NULL;
  tbl->capacity = 0;
  tbl->size     = 0;
  tbl->count    = 0;
}

/*Free a hash table storing pmds.*/
 inline
void _RV_hashtbl_free_pmd(_RV_hashtbl *tbl)
{
  if(tbl == NULL) return;
  _RV_hashtbl_free_slots_pmd(tbl);
  free(tbl);
}

/*Find the pmd of the given pointer address in the hash table.
  If the pmd does not exist, it returns NULL.*/
 inline
_RV_pmd *_RV_hashtbl_find_pmd(_RV_hashtbl *tbl, _RV_ptr_addr ptra)
{
  size_t index;
  _RV_pmd **prev;
  if(tbl == NULL) return NULL;

  index = _RV_hashtbl_hash((size_t)ptra, tbl->capacity);
  if(_RV_list_find_pmd_ref((_RV_pmd **)(tbl->slots + index), ptra, &prev))
    return *prev;
  return NULL;
}

/*Insert the given pmd to the hash table.
  If the pmd of the given pointer address already exists,
  the existing pmd will be replaced and freed.*/
 inline
_RV_pmd *_RV_hashtbl_insert_pmd(_RV_hashtbl *tbl, _RV_pmd *pmd)
{
  size_t index;
  _RV_pmd **prev;
  if(tbl == NULL || pmd == NULL) return NULL;

  index = _RV_hashtbl_hash((size_t)pmd->ptra, tbl->capacity);
  /*found: replace and free the existing pmd*/
  /*not found: insert pmd*/
  if(_RV_list_insert_pmd((_RV_pmd **)(tbl->slots + index), pmd, &prev))
  {
    if(prev == (_RV_pmd **)(tbl->slots + index) && (*prev)->next == NULL)
      tbl->size++;
    tbl->count++;
    _RV_hashtbl_resize_pmd(tbl);
  }
  return pmd;
}

/*Insert a pmd of the given pointer address to the hash table.
  If the pmd of the given pointer address already exists,
  the existing pmd will be returned.*/
 inline
_RV_pmd *_RV_hashtbl_insert_pmd_ptr(_RV_hashtbl *tbl, _RV_ptr_addr ptra)
{
  size_t index;
  _RV_pmd **prev, *cur;
  if(tbl == NULL) return NULL;

  index = _RV_hashtbl_hash((size_t)ptra, tbl->capacity);
  /*found: return the existing pmd*/
  if(!_RV_list_insert_pmd_ptr((_RV_pmd **)(tbl->slots + index), ptra, &prev))
    return *prev;
  /*not found: insert pmd*/
  cur = *prev; /*note: *prev != cur after resize*/
  if(prev == (_RV_pmd **)(tbl->slots + index) && cur->next == NULL)
    tbl->size++;
  tbl->count++;
  _RV_hashtbl_resize_pmd(tbl);
  return cur;
}

/*Remove and free the pmd of the given pointer address from the hash table.
  If a pmd is removed and freed, it returns 1. Otherwise, it returns 0.*/
 inline
int _RV_hashtbl_remove_pmd(_RV_hashtbl *tbl, _RV_ptr_addr ptra)
{
  size_t index;
  _RV_pmd **prev;
  if(tbl == NULL) return 0;

  index = _RV_hashtbl_hash((size_t)ptra, tbl->capacity);
  /*not found*/
  if(!_RV_list_remove_pmd((_RV_pmd **)(tbl->slots + index), ptra, &prev))
    return 0;
  /*found: remove the existing pmd*/
  if(prev == (_RV_pmd **)(tbl->slots + index) && *prev == NULL)
    tbl->size--;
  tbl->count--;
  return 1;
}

/*Resize a hash table storing pmds.
  If resizing is needed, the capacity of the hash table is doubled.
  Note that the pmds in the hash table will be re-ordered.*/
 inline
void _RV_hashtbl_resize_pmd(_RV_hashtbl *tbl)
{
  _RV_hashtbl *new_tbl;

  if(tbl == NULL || (tbl->count <= 3 * tbl->size))
    return;

  new_tbl = _RV_hashtbl_create(2*(tbl->capacity));
  new_tbl = _RV_hashtbl_transfer_pmds(tbl, new_tbl);
  free(tbl->slots);
  tbl->slots    = new_tbl->slots;
  tbl->capacity = new_tbl->capacity;
  tbl->size     = new_tbl->size;
  tbl->count    = new_tbl->count;
  free(new_tbl);
}

/*Transfer all pmds of an old hash table to a new hash table.
  It returns the hash table containing all these pmds.
  If new_tbl is NULL, it returns old_tbl.*/

_RV_hashtbl *_RV_hashtbl_transfer_pmds(_RV_hashtbl *old_tbl,
                                           _RV_hashtbl *new_tbl)
{
  size_t i;
  _RV_pmd *pmd, *pmd1;

  if(NULL == new_tbl) return old_tbl;
  if(NULL == old_tbl) return new_tbl;

  for(i = 0; i < old_tbl->capacity; i++)
  {
    pmd = (_RV_pmd *)old_tbl->slots[i];
    /*Remove the list of pmds from old_tbl.*/
    old_tbl->slots[i] = NULL;
    while(pmd != NULL)
    {
      pmd1 = pmd->next;
      pmd->next = NULL;
      _RV_hashtbl_insert_pmd(new_tbl, pmd);
      pmd = pmd1;
    }
  }
  old_tbl->size  = 0;
  old_tbl->count = 0;
  return new_tbl;
}

/*Get the reference of the hash table storing pmds.
  If it does not exist, an empty hash table will be created and returned.*/

_RV_hashtbl **_RV_hashtbl_get_hashtbl_ref_pmd()
{
  static _RV_hashtbl *tbl = NULL;
  if(NULL == tbl)
    tbl = _RV_hashtbl_create(1024);
  return &tbl;
}

/*Get the hash table storing pmds.
  If it does not exist, an empty hash table will be created and returned.*/
 inline
_RV_hashtbl *_RV_hashtbl_get_hashtbl_pmd()
{
  return *_RV_hashtbl_get_hashtbl_ref_pmd();
}

#endif

/*===----------------------------- hashtbl for fmd ------------------------===*/


void _RV_hashtbl_free_slots_fmd(_RV_hashtbl *tbl)
{
  size_t i;
  _RV_fmd *fmd, *fmd1;
  if(tbl == NULL || tbl->slots == NULL) return;
  for(i = 0; i < tbl->capacity; i++)
  {
    fmd = (_RV_fmd *)tbl->slots[i];
    while(fmd != NULL)
    {
      fmd1 = fmd->next;
      _RV_fmd_free(fmd);
      fmd = fmd1;
    }
  }
  free(tbl->slots);
  tbl->slots    = NULL;
  tbl->capacity = 0;
  tbl->size     = 0;
  tbl->count    = 0;
}

 inline
void _RV_hashtbl_free_fmd(_RV_hashtbl *tbl)
{
  if(tbl == NULL) return;
  _RV_hashtbl_free_slots_fmd(tbl);
  free(tbl);
}

 inline
_RV_fmd *_RV_hashtbl_find_fmd(_RV_hashtbl *tbl, _RV_func_addr func)
{
  size_t index;
  _RV_fmd **prev;
  if(tbl == NULL) return NULL;

  index = _RV_hashtbl_hash((size_t)func, tbl->capacity);
  if(_RV_list_find_fmd_ref((_RV_fmd **)(tbl->slots + index), func, &prev))
    return *prev;
  return NULL;
}

 inline
_RV_fmd *_RV_hashtbl_insert_fmd(_RV_hashtbl *tbl, _RV_fmd *fmd)
{
  size_t index;
  _RV_fmd **prev;
  if(tbl == NULL || fmd == NULL) return NULL;

  index = _RV_hashtbl_hash((size_t)fmd->func, tbl->capacity);
  /*found: replace and free the existing fmd*/
  /*not found: insert fmd*/
  if(_RV_list_insert_fmd((_RV_fmd **)(tbl->slots + index), fmd, &prev))
  {
    if(prev == (_RV_fmd **)(tbl->slots + index) && (*prev)->next == NULL)
      tbl->size++;
    tbl->count++;
    _RV_hashtbl_resize_fmd(tbl);
  }
  return fmd;
}

 inline
_RV_fmd *_RV_hashtbl_insert_fmd_func(_RV_hashtbl *tbl, _RV_func_addr func,
                                         unsigned char capacity)
{
  size_t index;
  _RV_fmd **prev, *cur;
  if(tbl == NULL) return NULL;

  index = _RV_hashtbl_hash((size_t)func, tbl->capacity);
  /*found: return the existing fmd*/
  if(!_RV_list_insert_fmd_func((_RV_fmd **)(tbl->slots + index), func, capacity, &prev))
  {
    _RV_fmd_resize_pmds(*prev, capacity, 0);
    return *prev;
  }
  /*not found: insert fmd*/
  cur = *prev; /*note: *prev != cur after resize*/
  if(prev == (_RV_fmd **)(tbl->slots + index) && cur->next == NULL)
    tbl->size++;
  tbl->count++;
  _RV_hashtbl_resize_fmd(tbl);
  return cur;
}

 inline
int _RV_hashtbl_remove_fmd(_RV_hashtbl *tbl, _RV_func_addr func)
{
  size_t index;
  _RV_fmd **prev;
  if(tbl == NULL) return 0;

  index = _RV_hashtbl_hash((size_t)func, tbl->capacity);
  /*not found*/
  if(!_RV_list_remove_fmd((_RV_fmd **)(tbl->slots + index), func, &prev))
    return 0;
  /*found: remove the existing fmd*/
  if(prev == (_RV_fmd **)(tbl->slots + index) && *prev == NULL)
    tbl->size--;
  tbl->count--;
  return 1;
}

 inline
void _RV_hashtbl_resize_fmd(_RV_hashtbl *tbl)
{
  _RV_hashtbl *new_tbl;

  if(tbl == NULL || (tbl->count <= 3 * tbl->size))
    return;

  new_tbl = _RV_hashtbl_create(2*(tbl->capacity));
  new_tbl = _RV_hashtbl_transfer_fmds(tbl, new_tbl);
  free(tbl->slots);
  tbl->slots    = new_tbl->slots;
  tbl->capacity = new_tbl->capacity;
  tbl->size     = new_tbl->size;
  tbl->count    = new_tbl->count;
  free(new_tbl);
}


_RV_hashtbl *_RV_hashtbl_transfer_fmds(_RV_hashtbl *old_tbl,
                                           _RV_hashtbl *new_tbl)
{
  size_t i;
  _RV_fmd *fmd, *fmd1;

  if(NULL == new_tbl) return old_tbl;
  if(NULL == old_tbl) return new_tbl;

  for(i = 0; i < old_tbl->capacity; i++)
  {
    fmd = (_RV_fmd *)old_tbl->slots[i];
    /*Remove the list of fmds from old_tbl.*/
    old_tbl->slots[i] = NULL;
    while(fmd != NULL)
    {
      fmd1 = fmd->next;
      fmd->next = NULL;
      _RV_hashtbl_insert_fmd(new_tbl, fmd);
      fmd = fmd1;
    }
  }
  old_tbl->size  = 0;
  old_tbl->count = 0;
  return new_tbl;
}


_RV_hashtbl **_RV_hashtbl_get_hashtbl_ref_fmd()
{
  static _RV_hashtbl *tbl = NULL;
  if(NULL == tbl)
    tbl = _RV_hashtbl_create(1024);
  return &tbl;
}

 inline
_RV_hashtbl *_RV_hashtbl_get_hashtbl_fmd()
{
  return *_RV_hashtbl_get_hashtbl_ref_fmd();
}

#if defined(_RV_use_one_fmd)

 inline
_RV_fmd **_RV_fmd_get_fmd_ref()
{
  static _RV_fmd *fmd = NULL;
  if(NULL == fmd)
    fmd = _RV_fmd_create(NULL, 32);
  return &fmd;
}

 inline
_RV_fmd *_RV_fmd_get_fmd()
{
  return *_RV_fmd_get_fmd_ref();
}

#endif
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for the functions related to
//  the algorithm for the dynamic analysis of memory safety.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- utilities ------------------------------===*/
int _RV_sstrlen(const char *str);
/*===----------------------------- pmd_tbl --------------------------------===*/
_RV_pmd *_RV_pmd_tbl_create(_RV_ptr_addr ptra);
_RV_pmd *_RV_pmd_tbl_lookup(_RV_ptr_addr ptra);
void       _RV_pmd_tbl_print(_RV_ptr_addr ptra, const char *ptr_name);
_RV_pmd *_RV_pmd_tbl_update_sa(_RV_ptr_addr ptra, _RV_stat_node *snda,
                         const void *base, const void *bound);
void      *_RV_pmd_tbl_update_sa_ret(_RV_ptr_addr ptra, _RV_stat_node *snda,
                         const void *base, const void *bound, const void *ret);
_RV_pmd *_RV_pmd_tbl_update_ns(_RV_ptr_addr ptra, _RV_status stat,
                         const void *base, const void *bound);
_RV_pmd *_RV_pmd_tbl_update_pmd(_RV_ptr_addr ptra, const _RV_pmd *pmd);
void      *_RV_pmd_tbl_update_pmd_ret(_RV_ptr_addr ptra, const _RV_pmd *pmd,
                         const void *ret);
_RV_pmd *_RV_pmd_tbl_update_fpmd(_RV_ptr_addr ptra, const _RV_fmd_pmd *fpmd);
_RV_pmd *_RV_pmd_tbl_update_ptr(_RV_ptr_addr ptra, _RV_ptr_addr ptra1);
void      *_RV_pmd_tbl_update_ptr_ret(_RV_ptr_addr ptra, _RV_ptr_addr ptra1,
                         const void *ret);
_RV_pmd *_RV_pmd_tbl_update_null(_RV_ptr_addr ptra);
void       _RV_pmd_tbl_remove(_RV_ptr_addr ptra);
void       _RV_pmd_tbl_remove_pa(_RV_ptr_addr array, size_t size);
void       _RV_pmd_var_remove_pa(_RV_pmd *array, size_t size);

_RV_pmd *_RV_pmd_tbl_update_argv(int argc, char ***argv_addr, char **argv);
_RV_pmd *_RV_pmd_var_update_argv(int argc, _RV_pmd *argv_pmd, char **argv);
void       _RV_pmd_tbl_remove_argv(int argc, char ***argv_addr, char **argv);
void       _RV_pmd_var_remove_argv(int argc, _RV_pmd *argv_pmd, char **argv);
_RV_pmd *_RV_pmd_tbl_update_envp(char ***envp_addr, char **envp);
_RV_pmd *_RV_pmd_var_update_envp(_RV_pmd *envp_pmd, char **envp);
void       _RV_pmd_tbl_remove_envp(char ***envp_addr, char **envp);
void       _RV_pmd_var_remove_envp(_RV_pmd *envp_pmd, char **envp);
/*===----------------------------- fmd_tbl --------------------------------===*/
_RV_fmd     *_RV_fmd_tbl_create(_RV_func_addr func, unsigned char capacity);
_RV_fmd     *_RV_fmd_tbl_lookup(_RV_func_addr func);
_RV_fmd_pmd *_RV_fmd_tbl_lookup_fpmd(_RV_func_addr func, unsigned char i);
void           _RV_fmd_tbl_print(_RV_func_addr func, unsigned char i,
                             const char *func_name);
_RV_fmd     *_RV_fmd_tbl_update_pmd(_RV_func_addr func, unsigned char i,
                             const _RV_pmd *pmd);
void           _RV_fmd_tbl_remove(_RV_func_addr func);
/*===----------------------------- check ----------------------------------===*/
void *_RV_check_dpv(const _RV_pmd *pmd,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
long _RV_check_dpv_ss(const _RV_pmd *pmd,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
void *_RV_check_dpfv(const _RV_pmd *pmd, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
void *_RV_check_dpc(const void *base, const void *bound,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
long _RV_check_dpc_ss(const void *base, const void *bound,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
void *_RV_check_dpfc(const void *base, const void *bound, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);

/*===----------------------------- utilities ------------------------------===*/


int _RV_sstrlen(const char *str)
{
  int length = 0;
  while(str && *str != '\0')
  {
    length++;
    str++;
  }
  return length;
}

/*===----------------------------- pmd_tbl --------------------------------===*/

/*Create the pmd of the pointer address ptra.
  If the pmd of the given pointer address already exists,
  the existing pmd will be returned.*/
 inline
_RV_pmd *_RV_pmd_tbl_create(_RV_ptr_addr ptra)
{
#if defined(_RV_use_trie)
  _RV_pmd **tbl = _RV_trie_get_trie_pmd();
  return _RV_trie_insert_pmd_ptr(tbl, ptra);
#elif defined(_RV_use_hashtable)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_pmd();
  return _RV_hashtbl_insert_pmd_ptr(tbl, ptra);
#endif
}

/*Lookup for the pmd of the pointer address ptra.*/
 inline
_RV_pmd *_RV_pmd_tbl_lookup(_RV_ptr_addr ptra)
{
#if defined(_RV_use_trie)
  _RV_pmd **tbl = _RV_trie_get_trie_pmd();
  return _RV_trie_find_pmd(tbl, ptra);
#elif defined(_RV_use_hashtable)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_pmd();
  return _RV_hashtbl_find_pmd(tbl, ptra);
#endif
}

/*Print the pmd of the pointer address ptra.*/
 inline
void _RV_pmd_tbl_print(_RV_ptr_addr ptra, const char *ptr_name)
{
  _RV_pmd *pmd = _RV_pmd_tbl_lookup(ptra);
  if(!pmd)
    printf("The pmd of %s (addr = %p) does not exist.\n", ptr_name, (void*)ptra);
  else
  {
    printf("The pmd of %s (addr = %p) is [%p, %p), status = ",
           ptr_name, (void*)ptra, pmd->base, pmd->bound);
    if(!pmd->snda)
      printf("(null)\n");
    else
      printf("(%d, %lu)\n", pmd->snda->stat, pmd->snda->count);
  }
}

/*Update the pmd of the pointer address ptra, using the given status, base and bound.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
_RV_pmd *_RV_pmd_tbl_update_sa(_RV_ptr_addr ptra, _RV_stat_node *snda,
                         const void *base, const void *bound)
{
#if defined(_RV_use_trie)
  _RV_pmd **tbl = _RV_trie_get_trie_pmd();
  _RV_pmd *pmd = _RV_trie_insert_pmd_ptr(tbl, ptra);
#elif defined(_RV_use_hashtable)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_pmd();
  _RV_pmd *pmd = _RV_hashtbl_insert_pmd_ptr(tbl, ptra);
#endif
  _RV_pmd_c_snda(pmd, snda);
  pmd->base  = base;
  pmd->bound = bound;
  return pmd;
}

 inline
void *_RV_pmd_tbl_update_sa_ret(_RV_ptr_addr ptra, _RV_stat_node *snda,
                         const void *base, const void *bound, const void *ret)
{
  _RV_pmd_tbl_update_sa(ptra, snda, base, bound);
  return (void *)ret;
}

/*Update the pmd of the pointer address ptra, using the given stat, base and bound.
  Note that a new status is created from the given stat.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
_RV_pmd *_RV_pmd_tbl_update_ns(_RV_ptr_addr ptra, _RV_status stat,
                         const void *base, const void *bound)
{
  _RV_stat_node *snda = _RV_stat_node_create(stat, 0);
  return _RV_pmd_tbl_update_sa(ptra, snda, base, bound);
}

/*Update the pmd of the pointer address ptra,
  using the status, base and bound of the given pmd.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
_RV_pmd *_RV_pmd_tbl_update_pmd(_RV_ptr_addr ptra, const _RV_pmd *pmd)
{
  if(pmd == NULL)
    return _RV_pmd_tbl_update_sa(ptra, NULL, NULL, NULL);
  else
    return _RV_pmd_tbl_update_sa(ptra, pmd->snda, pmd->base, pmd->bound);
}

 inline
void *_RV_pmd_tbl_update_pmd_ret(_RV_ptr_addr ptra, const _RV_pmd *pmd,
                                   const void *ret)
{
  _RV_pmd_tbl_update_pmd(ptra, pmd);
  return (void *)ret;
}

/*Update the pmd of the pointer address ptra,
  using the status, base and bound of the given pmd in function pointer metadata.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
_RV_pmd *_RV_pmd_tbl_update_fpmd(_RV_ptr_addr ptra, const _RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL)
    return _RV_pmd_tbl_update_sa(ptra, NULL, NULL, NULL);
  else
    return _RV_pmd_tbl_update_sa(ptra, fpmd->snda, fpmd->base, fpmd->bound);
}

/*Update the pmd of the pointer address ptra,
  using the status, base and bound of the pmd of the pointer address ptra1.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
_RV_pmd *_RV_pmd_tbl_update_ptr(_RV_ptr_addr ptra, _RV_ptr_addr ptra1)
{
  const _RV_pmd *pmd1 = _RV_pmd_tbl_lookup(ptra1);
  return _RV_pmd_tbl_update_pmd(ptra, pmd1);
}

 inline
void *_RV_pmd_tbl_update_ptr_ret(_RV_ptr_addr ptra, _RV_ptr_addr ptra1,
                                   const void *ret)
{
  _RV_pmd_tbl_update_ptr(ptra, ptra1);
  return (void *)ret;
}

/*Update the pmd of the pointer address ptra, using null.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
_RV_pmd *_RV_pmd_tbl_update_null(_RV_ptr_addr ptra)
{
#if defined(_RV_use_trie)
  _RV_pmd **tbl = _RV_trie_get_trie_pmd();
  _RV_pmd *pmd = _RV_trie_insert_pmd_ptr(tbl, ptra);
#elif defined(_RV_use_hashtable)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_pmd();
  _RV_pmd *pmd = _RV_hashtbl_insert_pmd_ptr(tbl, ptra);
#endif
  _RV_pmd_set_null(pmd);
  return pmd;
}

/*Remove the pmd of the pointer address ptra.*/
 inline
void _RV_pmd_tbl_remove(_RV_ptr_addr ptra)
{
#if defined(_RV_use_trie)
  _RV_pmd **tbl = _RV_trie_get_trie_pmd();
  _RV_trie_remove_pmd(tbl, ptra);
#elif defined(_RV_use_hashtable)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_pmd();
  _RV_hashtbl_remove_pmd(tbl, ptra);
#endif
}

/*Remove the pmds of an array of pointers, e.g., void *array[size].*/

void _RV_pmd_tbl_remove_pa(_RV_ptr_addr array, size_t size)
{
  size_t i;
#if defined(_RV_use_trie)
  _RV_pmd **tbl = _RV_trie_get_trie_pmd();
  for(i = 0; i < size; i++)
    _RV_trie_remove_pmd(tbl, array+i);
#elif defined(_RV_use_hashtable)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_pmd();
  for(i = 0; i < size; i++)
    _RV_hashtbl_remove_pmd(tbl, array+i);
#endif
}


void _RV_pmd_var_remove_pa(_RV_pmd *array, size_t size)
{
  size_t i;
  for(i = 0; i < size; i++)
    _RV_pmd_set_null(array+i);
}

/*Update the pmds of an array of char pointers, e.g., char *argv[argc].
  If the pmd does not exist, a new pmd is created and inserted.*/

_RV_pmd *_RV_pmd_tbl_update_argv(int argc, char ***argv_addr, char **argv)
{
  int i;
  _RV_stat_node *sa = _RV_stat_node_create(_RV_stack, 0);
  for(i = 0; i < argc; i++)
    _RV_pmd_tbl_update_sa((_RV_ptr_addr)(argv+i), sa,
                            argv[i], argv[i] + _RV_sstrlen(argv[i]) + 1);
  return
    _RV_pmd_tbl_update_sa((_RV_ptr_addr)argv_addr, sa,
                            argv, argv + argc);
}


_RV_pmd *_RV_pmd_var_update_argv(int argc, _RV_pmd *argv_pmd, char **argv)
{
  int i;
  _RV_stat_node *sa = _RV_stat_node_create(_RV_stack, 0);
  for(i = 0; i < argc; i++)
    _RV_pmd_tbl_update_sa((_RV_ptr_addr)(argv+i), sa,
                            argv[i], argv[i] + _RV_sstrlen(argv[i]) + 1);
  return
    _RV_pmd_set(argv_pmd, sa, _RV_invalid, argv, argv + argc);
}

/*Remove the pmds of an array of char pointers, e.g., char *argv[argc].*/
 inline
void _RV_pmd_tbl_remove_argv(int argc, char ***argv_addr, char **argv)
{
  _RV_pmd_tbl_remove_pa((_RV_ptr_addr)argv, argc);
  _RV_pmd_tbl_remove((_RV_ptr_addr)argv_addr);
}

 inline
void _RV_pmd_var_remove_argv(int argc, _RV_pmd *argv_pmd, char **argv)
{
  _RV_pmd_tbl_remove_pa((_RV_ptr_addr)argv, argc);
  _RV_pmd_set_null(argv_pmd);
}

/*Update the pmds of an array of char pointers, e.g., char **envp.
  If the pmd does not exist, a new pmd is created and inserted.*/

_RV_pmd *_RV_pmd_tbl_update_envp(char ***envp_addr, char **envp)
{
  int i = 0;
  _RV_stat_node *sa = _RV_stat_node_create(_RV_stack, 0);
  while(envp[i] != NULL)
  {
    _RV_pmd_tbl_update_sa((_RV_ptr_addr)(envp+i), sa,
                            envp[i], envp[i] + _RV_sstrlen(envp[i]) + 1);
    i++;
  }
  return
    _RV_pmd_tbl_update_sa((_RV_ptr_addr)envp_addr, sa,
                            envp, envp + i + 1);
}


_RV_pmd *_RV_pmd_var_update_envp(_RV_pmd *envp_pmd, char **envp)
{
  int i = 0;
  _RV_stat_node *sa = _RV_stat_node_create(_RV_stack, 0);
  while(envp[i] != NULL)
  {
    _RV_pmd_tbl_update_sa((_RV_ptr_addr)(envp+i), sa,
                            envp[i], envp[i] + _RV_sstrlen(envp[i]) + 1);
    i++;
  }
  return
    _RV_pmd_set(envp_pmd, sa, _RV_invalid, envp, envp + i + 1);
}

/*Remove the pmds of an array of char pointers, e.g., char **envp,*/

void _RV_pmd_tbl_remove_envp(char ***envp_addr, char **envp)
{
  int i = 0;
  while(envp[i] != NULL)
  {
    _RV_pmd_tbl_remove((_RV_ptr_addr)(envp+i));
    i++;
  }
  _RV_pmd_tbl_remove((_RV_ptr_addr)envp_addr);
}


void _RV_pmd_var_remove_envp(_RV_pmd *envp_pmd, char **envp)
{
  int i = 0;
  while(envp[i] != NULL)
  {
    _RV_pmd_tbl_remove((_RV_ptr_addr)(envp+i));
    i++;
  }
  _RV_pmd_set_null(envp_pmd);
}

/*===----------------------------- fmd_tbl --------------------------------===*/

/*Create a function pointer metadata of the given capacity.*/
 inline
_RV_fmd *_RV_fmd_tbl_create(_RV_func_addr func, unsigned char capacity)
{
#if !defined(_RV_use_one_fmd)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_fmd();
  _RV_fmd *fmd = _RV_hashtbl_insert_fmd_func(tbl, func, capacity);
#elif defined(_RV_use_one_fmd)
  _RV_fmd *fmd = _RV_fmd_get_fmd();
  fmd->func = func;
  _RV_fmd_resize_pmds(fmd, capacity, 1);
#elif
  assert(false, "Unconsidered cases in _RV_fmd_tbl_create()!");
#endif
  _RV_fmd_set_null(fmd);
  return fmd;
}

/*Lookup for the function pointer metadata of the function address func.*/
 inline
_RV_fmd *_RV_fmd_tbl_lookup(_RV_func_addr func)
{
#if !defined(_RV_use_one_fmd)
  _RV_hashtbl *tbl = _RV_hashtbl_get_hashtbl_fmd();
  return _RV_hashtbl_find_fmd(tbl, func);
#elif defined(_RV_use_one_fmd)
  return _RV_fmd_get_fmd();
#elif
  assert(false, "Unconsidered cases in _RV_fmd_tbl_create()!");
#endif
}

/*Lookup for the i-th pmd in the function pointer metadata of the function address func.*/
 inline
_RV_fmd_pmd *_RV_fmd_tbl_lookup_fpmd(_RV_func_addr func, unsigned char i)
{
  const _RV_fmd *fmd = _RV_fmd_tbl_lookup(func);
  return _RV_fmd_get_fmd_pmd(fmd, i);
}

/*Print the i-th pmd in the function pointer metadata of the function address func.*/
 inline
void _RV_fmd_tbl_print(_RV_func_addr func, unsigned char i, const char *func_name)
{
  const _RV_fmd_pmd *fpmd = _RV_fmd_tbl_lookup_fpmd(func, i);
  if(!fpmd)
    printf("The fpmd of %s (param %d) does not exist.\n", func_name, i);
  else
  {
    printf("The fpmd of %s (param %d) is [%p, %p), status = ",
           func_name, i, fpmd->base, fpmd->bound);
    if(!fpmd->snda)
      printf("(null)\n");
    else
      printf("(%d, %lu)\n", fpmd->snda->stat, fpmd->snda->count);
  }
}

/*Update the i-th pmd in the function pointer metadata of the function address func,
  using the status, base and bound of the given pmd.*/
 inline
_RV_fmd *_RV_fmd_tbl_update_pmd(_RV_func_addr func, unsigned char i,
                                    const _RV_pmd *pmd)
{
  _RV_fmd *fmd = _RV_fmd_tbl_lookup(func);
  _RV_fmd_cp_pmd(fmd, i, pmd);
  return fmd;
}

/*Remove the function pointer metadata of the function address func.*/
 inline
void _RV_fmd_tbl_remove(_RV_func_addr func)
{
  _RV_fmd *fmd = _RV_fmd_tbl_lookup(func);
  _RV_fmd_set_null(fmd);
}

/*===----------------------------- check ----------------------------------===*/

/*Check deferences of pointer variables, e.g., *ptr.*/
 inline
void *_RV_check_dpv(const _RV_pmd *pmd,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  _RV_status stat = _RV_pmd_get_stat(pmd);

  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
           file_name, line, column, ptr_name);
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check temporal errors, incl. object and sub-object.*/
#if defined(_RV_use_trie)
  if(pmd == NULL || pmd->pmdflag == 0)
#else
  if(pmd == NULL)
#endif
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, line, column, ptr_name, ptr, size);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  if(stat == _RV_invalid)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object. "
           "[temporal error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "points to an invalid object (original block is [%p, %p)). "
           "[temporal error]\n",
           file_name, line, column, ptr_name, ptr, size, pmd->base, pmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check segment errors.*/
  if(stat == _RV_function)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to a function, not a data block. [segment error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "points to a function %p, not a data block. [segment error]\n",
           file_name, line, column, ptr_name, ptr, size, pmd->base);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr < pmd->base || (char*)ptr + size > (char*)pmd->bound ||
                        (char*)ptr + size < (char*)ptr)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is out of the block. [spatial error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "is out of the block [%p, %p). [spatial error]\n",
           file_name, line, column, ptr_name, ptr, size, pmd->base, pmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  return (void *)ptr;
}

/*Check deferences of pointer variables using subscripts, e.g., ptr[subscript].*/
 inline
long _RV_check_dpv_ss(const _RV_pmd *pmd,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  _RV_check_dpv(pmd, (char*)ptr + subscript * size, size,
                  file_name, func_name, line, column, ptr_name);
  return subscript;
}

/*Check deferences of function pointer variables, e.g., ptr() and (*ptr)().*/
 inline
void *_RV_check_dpfv(const _RV_pmd *pmd, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  _RV_status stat = _RV_pmd_get_stat(pmd);

  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
           file_name, line, column, ptr_name);
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check temporal errors, incl. object and sub-object.*/
#if defined(_RV_use_trie)
  if(pmd == NULL || pmd->pmdflag == 0)
#else
  if(pmd == NULL)
#endif
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, line, column, ptr_name, ptr);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  if(stat == _RV_invalid)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object. "
           "[temporal error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "points to an invalid object (original block is [%p, %p)). "
           "[temporal error]\n",
           file_name, line, column, ptr_name, ptr, pmd->base, pmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check segment errors.*/
  if(stat != _RV_function && stat != _RV_library)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "does not point to a function, but a data block. [segment error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "does not point to a function, but a data block [%p, %p). [segment error]\n",
           file_name, line, column, ptr_name, ptr, pmd->base, pmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr != pmd->base)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is not the address of a function. [spatial error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "is not the address of the function %p. [spatial error]\n",
           file_name, line, column, ptr_name, ptr, pmd->base);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  return (void *)ptr;
}

/*Check deferences of pointer constants, e.g., *ptr.*/
 inline
void *_RV_check_dpc(const void *base, const void *bound,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
           file_name, line, column, ptr_name);
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr < base || (char*)ptr + size > (char*)bound ||
                   (char*)ptr + size < (char*)ptr)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is out of the block. [spatial error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "is out of the block [%p, %p). [spatial error]\n",
           file_name, line, column, ptr_name, ptr, size, base, bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  return (void *)ptr;
}

/*Check deferences of pointer constants using subscripts, e.g., ptr[subscript].*/
 inline
long _RV_check_dpc_ss(const void *base, const void *bound,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  _RV_check_dpc(base, bound, (char*)ptr + subscript * size, size,
                  file_name, func_name, line, column, ptr_name);
  return subscript;
}

/*Check deferences of function pointer constants, e.g., ((void (*)())100)().*/
 inline
void *_RV_check_dpfc(const void *base, const void *bound, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
           file_name, line, column, ptr_name);
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr != base)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is not the address of a function. [spatial error]\n",
           file_name, line, column, ptr_name);
#else
    fprintf(stderr,"%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "is not the address of the function %p. [spatial error]\n",
           file_name, line, column, ptr_name, ptr, base);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
    return (void *)ptr;
  }

  return (void *)ptr;
}
/*********************************** ctype.h **********************************/
#include <ctype.h>

/* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.

   In the thread-specific locale model (see `uselocale' in <locale.h>)
   we cannot use global variables for these as was done in the past.
   Instead, the following accessor functions return the address of
   each variable, which is local to the current thread if multithreaded.

   These point into arrays of 384, so they can be indexed by any `unsigned
   char' value [0,255]; by EOF (-1); or by any `signed char' value
   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
   char' values and for EOF; we also support negative `signed char' values
   for broken old programs.  The case conversion arrays are of `int's
   rather than `unsigned char's because tolower (EOF) must be EOF, which
   doesn't fit into an `unsigned char'.  But today more important is that
   the arrays are also used for multi-byte character sets.  */
extern _RV_stat_node *_RV_global_sa;
extern _RV_stat_node *_RV_static_sa;
 unsigned short **_RV___ctype_b_loc(_RV_pmd *ret_pmd)
{
  unsigned short **ret;
  ret = (unsigned short **)__ctype_b_loc();

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
                  ret, ret + 1);
    _RV_pmd_tbl_update_sa((_RV_ptr_addr)ret, _RV_static_sa,
            (char*)(*ret) - 128*sizeof(char),
            (char*)(*ret) + 256*sizeof(char));
  }
  return ret;
}
/***************************** getopt.h ********************************/
#if defined(_DEFAULT_SOURCE)
#include <getopt.h>

extern char *optarg;
extern int optind, opterr, optopt;
 int _RV_getopt_long(_RV_pmd *argv_pmd, _RV_pmd *optstring_pmd,
        _RV_pmd *longopts_pmd, _RV_pmd *longindex_pmd,
        int argc, char * const argv[], const char *optstring,
        const struct option *longopts, int *longindex,
        const char *file_name, const char *func_name,
        unsigned  a_line, unsigned  a_col, const char  *a_name,
        unsigned  o_line, unsigned  o_col, const char  *o_name,
        unsigned lo_line, unsigned lo_col, const char *lo_name,
        unsigned li_line, unsigned li_col, const char *li_name)
{
  int ret, i; _RV_pmd *pmd;
  _RV_check_dpv(optstring_pmd, optstring, _RV_sstrlen(optstring) + 1,
                  file_name, func_name, o_line, o_col, o_name);
  if(longindex != NULL)
  _RV_check_dpv(longindex_pmd, longindex, sizeof(int),
                  file_name, func_name, li_line, li_col, li_name);

  ret = getopt_long(argc, argv, optstring, longopts, longindex);

  if(optarg == NULL)
    _RV_pmd_tbl_remove((_RV_ptr_addr)&optarg);
  else
  {
    for(i = 0; i < argc; i++)
    {
      pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)&argv[i]);
      if(_RV_pmd_get_base(pmd) <= (void*)optarg &&
         (void*)optarg < _RV_pmd_get_bound(pmd))
        _RV_pmd_tbl_update_ptr((_RV_ptr_addr)&optarg, (_RV_ptr_addr)&argv[i]);
    }
  }

  _RV_pmd_free_null_ptr(argv_pmd);
  _RV_pmd_free_null_ptr(optstring_pmd);
  _RV_pmd_free_null_ptr(longopts_pmd);
  _RV_pmd_free_null_ptr(longindex_pmd);
  return ret;
}
#endif
/******************************* locale.h *************************************/
#include <locale.h>

 char *_RV_setlocale(_RV_pmd *ret_pmd, _RV_pmd *locale_pmd,
        int category, char *locale,
        const char *file_name, const char *func_name,
        unsigned l_line, unsigned l_col, const char *l_name)
{
  char *ret;
  if(locale)
    _RV_check_dpv(locale_pmd, locale, _RV_sstrlen(locale)+1,
                    file_name, func_name, l_line, l_col, l_name);

  ret = setlocale(category, locale);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
            (void*)ret, (void*)(ret + _RV_sstrlen(ret) + 1));

  _RV_pmd_free_null_ptr(locale_pmd);
  return ret;
}

 struct lconv *_RV_localeconv(_RV_pmd *ret_pmd)
{
  struct lconv *ret;
  ret = localeconv();

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
            (void*)ret, (void*)(ret + 1));

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->decimal_point), _RV_global_sa,
            (void*)(ret->decimal_point),
            (char*)(ret->decimal_point) + _RV_sstrlen(ret->decimal_point) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->thousands_sep), _RV_global_sa,
            (void*)(ret->thousands_sep),
            (char*)(ret->thousands_sep) + _RV_sstrlen(ret->thousands_sep) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->grouping), _RV_global_sa,
            (void*)(ret->grouping),
            (char*)(ret->grouping) + _RV_sstrlen(ret->grouping) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->int_curr_symbol), _RV_global_sa,
            (void*)(ret->int_curr_symbol),
            (char*)(ret->int_curr_symbol) + _RV_sstrlen(ret->int_curr_symbol) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->currency_symbol), _RV_global_sa,
            (void*)(ret->currency_symbol),
            (char*)(ret->currency_symbol) + _RV_sstrlen(ret->currency_symbol) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->mon_decimal_point), _RV_global_sa,
            (void*)(ret->mon_decimal_point),
            (char*)(ret->mon_decimal_point) + _RV_sstrlen(ret->mon_decimal_point) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->mon_thousands_sep), _RV_global_sa,
            (void*)(ret->mon_thousands_sep),
            (char*)(ret->mon_thousands_sep) + _RV_sstrlen(ret->mon_thousands_sep) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->mon_grouping), _RV_global_sa,
            (void*)(ret->mon_grouping),
            (char*)(ret->mon_grouping) + _RV_sstrlen(ret->mon_grouping) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->positive_sign), _RV_global_sa,
            (void*)(ret->positive_sign),
            (char*)(ret->positive_sign) + _RV_sstrlen(ret->positive_sign) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->negative_sign), _RV_global_sa,
            (void*)(ret->negative_sign),
            (char*)(ret->negative_sign) + _RV_sstrlen(ret->negative_sign) + 1);
  }
  return ret;
}
/******************************* math.h ***************************************/
#include <math.h>

 double _RV_frexp(_RV_pmd *exponent_pmd,
        double x, int *exponent,
        const char *file_name, const char *func_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  _RV_check_dpv(exponent_pmd, exponent, sizeof(int),
                  file_name, func_name, e_line, e_col, e_name);
  _RV_pmd_free_null_ptr(exponent_pmd);
  return frexp(x, exponent);
}

 double _RV_modf(_RV_pmd *integer_pmd,
        double x, double *integer,
        const char *file_name, const char *func_name,
        unsigned i_line, unsigned i_col, const char *i_name)
{
  _RV_check_dpv(integer_pmd, integer, sizeof(double),
                  file_name, func_name, i_line, i_col, i_name);
  _RV_pmd_free_null_ptr(integer_pmd);
  return modf(x, integer);
}

/***************************** pwd.h ********************************/
#include <sys/types.h>
#include <pwd.h>

 struct passwd *_RV_getpwnam(_RV_pmd *ret_pmd,
        _RV_pmd *name_pmd,
        const char *name,
        const char *file_name, const char *func_name,
        unsigned n_line, unsigned n_col, const char *n_name)
{
  struct passwd *ret;
  if(name)
    _RV_check_dpv(name_pmd, name, _RV_sstrlen(name)+1,
                    file_name, func_name, n_line, n_col, n_name);

  ret = getpwnam(name);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
            (void*)ret, (void*)(ret + 1));

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_name), _RV_global_sa,
            (void*)(ret->pw_name),
            (char*)(ret->pw_name) + _RV_sstrlen(ret->pw_name) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_passwd), _RV_global_sa,
            (void*)(ret->pw_passwd),
            (char*)(ret->pw_passwd) + _RV_sstrlen(ret->pw_passwd) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_gecos), _RV_global_sa,
            (void*)(ret->pw_gecos),
            (char*)(ret->pw_gecos) + _RV_sstrlen(ret->pw_gecos) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_dir), _RV_global_sa,
            (void*)(ret->pw_dir),
            (char*)(ret->pw_dir) + _RV_sstrlen(ret->pw_dir) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_shell), _RV_global_sa,
            (void*)(ret->pw_shell),
            (char*)(ret->pw_shell) + _RV_sstrlen(ret->pw_shell) + 1);
  }

  _RV_pmd_free_null_ptr(name_pmd);
  return ret;
}

 struct passwd *_RV_getpwuid(_RV_pmd *ret_pmd,
        uid_t uid)
{
  struct passwd *ret = getpwuid(uid);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
            (void*)ret, (void*)(ret + 1));

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_name), _RV_global_sa,
            (void*)(ret->pw_name),
            (char*)(ret->pw_name) + _RV_sstrlen(ret->pw_name) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_passwd), _RV_global_sa,
            (void*)(ret->pw_passwd),
            (char*)(ret->pw_passwd) + _RV_sstrlen(ret->pw_passwd) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_gecos), _RV_global_sa,
            (void*)(ret->pw_gecos),
            (char*)(ret->pw_gecos) + _RV_sstrlen(ret->pw_gecos) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_dir), _RV_global_sa,
            (void*)(ret->pw_dir),
            (char*)(ret->pw_dir) + _RV_sstrlen(ret->pw_dir) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_shell), _RV_global_sa,
            (void*)(ret->pw_shell),
            (char*)(ret->pw_shell) + _RV_sstrlen(ret->pw_shell) + 1);
  }
  return ret;
}

#if defined(_DEFAULT_SOURCE)
 struct passwd *_RV_getpwent(_RV_pmd *ret_pmd)
{
  struct passwd *ret = getpwent();

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
            (void*)ret, (void*)(ret + 1));

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_name), _RV_global_sa,
            (void*)(ret->pw_name),
            (char*)(ret->pw_name) + _RV_sstrlen(ret->pw_name) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_passwd), _RV_global_sa,
            (void*)(ret->pw_passwd),
            (char*)(ret->pw_passwd) + _RV_sstrlen(ret->pw_passwd) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_gecos), _RV_global_sa,
            (void*)(ret->pw_gecos),
            (char*)(ret->pw_gecos) + _RV_sstrlen(ret->pw_gecos) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_dir), _RV_global_sa,
            (void*)(ret->pw_dir),
            (char*)(ret->pw_dir) + _RV_sstrlen(ret->pw_dir) + 1);

    _RV_pmd_tbl_update_sa((_RV_ptr_addr)&(ret->pw_shell), _RV_global_sa,
            (void*)(ret->pw_shell),
            (char*)(ret->pw_shell) + _RV_sstrlen(ret->pw_shell) + 1);
  }
  return ret;
}
#endif
/******************************* setjmp.h *************************************/
#include <setjmp.h>

 void _RV_longjmp(_RV_pmd *env_pmd,
        jmp_buf env, int value,
        const char *file_name, const char *func_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  _RV_check_dpv(env_pmd, env, sizeof(struct __jmp_buf_tag),
                  file_name, func_name, e_line, e_col, e_name);
  _RV_pmd_free_null_ptr(env_pmd);
  longjmp(env, value);
}
/******************************* signal.h *************************************/
#include <signal.h>

/*typedef void (*__sighandler_t)(int)*/
 __sighandler_t _RV_signal(_RV_pmd *ret_pmd, _RV_pmd *handler_pmd,
        int signum, __sighandler_t handler,
        const char *file_name, const char *func_name,
        unsigned h_line, unsigned h_col, const char *h_name)
{
  __sighandler_t ret;
  _RV_check_dpfv(handler_pmd, handler,
                   file_name, func_name, h_line, h_col, h_name);

  ret = signal(signum, handler);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
                  ret, (char*)ret + 1);

  _RV_pmd_free_null_ptr(handler_pmd);
  return ret;
}
/****************************** sys/stat.h ************************************/
#include <sys/stat.h>

 int _RV_fstat(_RV_pmd *buf_pmd,
        int fd, struct stat *buf,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  _RV_check_dpv(buf_pmd, buf, sizeof(struct stat),
                  file_name, func_name, b_line, b_col, b_name);
  _RV_pmd_free_null_ptr(buf_pmd);
  return fstat(fd, buf);
}
/******************************* stdio.h **************************************/
#include <stdio.h>

 int _RV_fclose(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_set_stat(fp_pmd, _RV_invalid);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fclose(fp);
}

 void _RV_clearerr(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  clearerr(fp);
}

 int _RV_feof(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return feof(fp);
}

 int _RV_ferror(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return ferror(fp);
}

 int _RV_fflush(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fflush(fp);
}

 int _RV_fgetpos(_RV_pmd *fp_pmd, _RV_pmd *pos_pmd,
        FILE *fp, fpos_t *pos,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(pos_pmd, pos, sizeof(fpos_t),
                  file_name, func_name, p_line, p_col, p_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  _RV_pmd_free_null_ptr(pos_pmd);
  return fgetpos(fp, pos);
}

 FILE *_RV_fopen(_RV_pmd *ret_pmd,
        _RV_pmd *filename_pmd, _RV_pmd *mode_pmd,
        const char *filename, char *mode,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned m_line, unsigned m_col, const char *m_name)
{
  FILE *ret;
  _RV_check_dpv(filename_pmd, filename, _RV_sstrlen(filename)+1,
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(mode_pmd, mode, _RV_sstrlen(mode)+1,
                  file_name, func_name, m_line, m_col, m_name);

  ret = fopen(filename, mode);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, NULL, _RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  _RV_pmd_free_null_ptr(filename_pmd);
  _RV_pmd_free_null_ptr(mode_pmd);
  return ret;
}

#if !defined(_POSIX_C_SOURCE)
 int _RV_fdopen(
        _RV_pmd *mode_pmd,
        int fd, char *mode,
        const char *file_name, const char *func_name,
        unsigned m_line, unsigned m_col, const char *m_name)
{
  _RV_check_dpv(mode_pmd, mode, _RV_sstrlen(mode)+1,
                  file_name, func_name, m_line, m_col, m_name);
  _RV_pmd_free_null_ptr(mode_pmd);
  return fdopen(fd, mode);
}
#else
 FILE *_RV_fdopen(_RV_pmd *ret_pmd,
        _RV_pmd *mode_pmd,
        int fd, char *mode,
        const char *file_name, const char *func_name,
        unsigned m_line, unsigned m_col, const char *m_name)
{
  FILE *ret;
  _RV_check_dpv(mode_pmd, mode, _RV_sstrlen(mode)+1,
                  file_name, func_name, m_line, m_col, m_name);

  ret = fdopen(fd, mode);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, NULL, _RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  _RV_pmd_free_null_ptr(mode_pmd);
  return ret;
}
#endif

 FILE *_RV_freopen(_RV_pmd *ret_pmd,
        _RV_pmd *filename_pmd, _RV_pmd *mode_pmd, _RV_pmd *fp_pmd,
        char *filename, char *mode, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned m_line, unsigned m_col, const char *m_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  FILE *ret;
  _RV_check_dpv(filename_pmd, filename, _RV_sstrlen(filename)+1,
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(mode_pmd, mode, _RV_sstrlen(mode)+1,
                  file_name, func_name, m_line, m_col, m_name);
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, p_line, p_col, p_name);

  ret = freopen(filename, mode, fp);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, NULL, _RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  _RV_pmd_free_null_ptr(filename_pmd);
  _RV_pmd_free_null_ptr(mode_pmd);
  _RV_pmd_free_null_ptr(fp_pmd);

  return ret;
}

 int _RV_fileno(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fileno(fp);
}

 size_t _RV_fread(_RV_pmd *ptr_pmd, _RV_pmd *fp_pmd,
        void *ptr, size_t size, size_t nmemb, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(ptr_pmd, ptr, size * nmemb,
                  file_name, func_name, p_line, p_col, p_name);
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(ptr_pmd);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fread(ptr, size, nmemb, fp);
}

 int _RV_fseek(_RV_pmd *fp_pmd,
        FILE *fp, long int offset, int whence,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fseek(fp, offset, whence);
}

 int _RV_fsetpos(_RV_pmd *fp_pmd, _RV_pmd *pos_pmd,
        FILE *fp, fpos_t *pos,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(pos_pmd, pos, sizeof(fpos_t),
                  file_name, func_name, p_line, p_col, p_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  _RV_pmd_free_null_ptr(pos_pmd);
  return fsetpos(fp, pos);
}

 long int _RV_ftell(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return ftell(fp);
}

 size_t _RV_fwrite(_RV_pmd *ptr_pmd, _RV_pmd *fp_pmd,
        const void *ptr, size_t size, size_t nmemb, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(ptr_pmd, ptr, size*nmemb,
                  file_name, func_name, p_line, p_col, p_name);
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(ptr_pmd);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fwrite(ptr, size, nmemb, fp);
}

 int _RV_remove(_RV_pmd *filename_pmd,
        const char *filename,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(filename_pmd, filename, _RV_sstrlen(filename)+1,
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(filename_pmd);
  return remove(filename);
}

 int _RV_rename(_RV_pmd *old_pmd, _RV_pmd *new_pmd,
        const char *old_filename, const char *new_filename,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned n_line, unsigned n_col, const char *n_name)
{
  _RV_check_dpv(old_pmd, old_filename, _RV_sstrlen(old_filename)+1,
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(new_pmd, new_filename, _RV_sstrlen(new_filename)+1,
                  file_name, func_name, n_line, n_col, n_name);
  _RV_pmd_free_null_ptr(old_pmd);
  _RV_pmd_free_null_ptr(new_pmd);
  return rename(old_filename, new_filename);
}

 void _RV_rewind(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  rewind(fp);
}

 void _RV_setbuf(_RV_pmd *fp_pmd, _RV_pmd *buffer_pmd,
        FILE *fp, char *buffer,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  if(buffer)
  _RV_check_dpv(buffer_pmd, buffer, 1,
                  file_name, func_name, b_line, b_col, b_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  _RV_pmd_free_null_ptr(buffer_pmd);
  setbuf(fp, buffer);
}

 int _RV_setvbuf(_RV_pmd *fp_pmd, _RV_pmd *buffer_pmd,
        FILE *fp, char *buffer, int mode, size_t size,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  if(buffer)
  _RV_check_dpv(buffer_pmd, buffer, size,
                  file_name, func_name, b_line, b_col, b_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  _RV_pmd_free_null_ptr(buffer_pmd);
  return setvbuf(fp, buffer, mode, size);
}

 FILE *_RV_tmpfile(_RV_pmd *ret_pmd)
{
  FILE *ret;
  ret = tmpfile();

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
  {
    _RV_pmd_set(ret_pmd, NULL, _RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  return ret;
}

#if defined(__GNUC__)
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#endif
extern _RV_stat_node *_RV_static_sa;
 char *_RV_tmpnam(_RV_pmd *ret_pmd,
        _RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);

  #if defined(__GNUC__)
  static char temp_file[L_tmpnam] = "tmp_XXXXXX";
  int fd = mkstemp(temp_file);
  unlink(temp_file);
  close(fd);
  if(str == NULL)
    ret = temp_file;
  else {
    strcpy(str, temp_file);
    ret = str;
  }
  #else
    ret = tmpnam(str);
  #endif

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_static_sa, _RV_invalid,
                  ret, ret + _RV_sstrlen(ret) + 1);

  _RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

 int _RV_vfprintf(
        _RV_pmd *fp_pmd, _RV_pmd *format_pmd, _RV_pmd *arg_va_list, _RV_pmd *arg_pmd,
        FILE *fp, const char *format, va_list arg,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned r_line, unsigned r_col, const char *r_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(format_pmd, format, _RV_sstrlen(format)+1,
                  file_name, func_name, r_line, r_col, r_name);
  _RV_check_dpv(arg_pmd, arg, sizeof(va_list), /*sizeof(*va_list)*/
                  file_name, func_name, a_line, a_col, a_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  _RV_pmd_free_null_ptr(format_pmd);
  _RV_pmd_free_null_ptr(arg_va_list);
  _RV_pmd_free_null_ptr(arg_pmd);
  return vfprintf(fp, format, arg);
}

 int _RV_vprintf(_RV_pmd *format_pmd, _RV_pmd *arg_va_list, _RV_pmd *arg_pmd,
        const char *format, va_list arg,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  _RV_check_dpv(format_pmd, format, _RV_sstrlen(format)+1,
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(arg_pmd, arg, sizeof(va_list), /*sizeof(*va_list)*/
                  file_name, func_name, a_line, a_col, a_name);
  _RV_pmd_free_null_ptr(format_pmd);
  _RV_pmd_free_null_ptr(arg_va_list);
  _RV_pmd_free_null_ptr(arg_pmd);
  return vprintf(format, arg);
}

 int _RV_vsprintf(
        _RV_pmd *str_pmd, _RV_pmd *format_pmd, _RV_pmd *arg_va_list, _RV_pmd *arg_pmd,
        char *str, const char *format, va_list arg,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  char buffer[BUFSIZ];
  int ret;
  _RV_check_dpv(format_pmd, format, _RV_sstrlen(format)+1,
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(arg_pmd, arg, sizeof(va_list), /*sizeof(*va_list)*/
                  file_name, func_name, a_line, a_col, a_name);

  ret = vsprintf(buffer, format, arg);
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(buffer)+1,
                  file_name, func_name, s_line, s_col, s_name);
  strcpy(str, buffer);

  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(format_pmd);
  _RV_pmd_free_null_ptr(arg_va_list);
  _RV_pmd_free_null_ptr(arg_pmd);
  return ret;
}

 int _RV_fgetc(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fgetc(fp);
}

 char *_RV_fgets(_RV_pmd *ret_pmd,
        _RV_pmd *str_pmd, _RV_pmd *fp_pmd,
        char *str, int n, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  char *ret;
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);

  ret = fgets(str, n, fp);
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, str_pmd);

  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(fp_pmd);
  return ret;
}

 int _RV_fputc(_RV_pmd *fp_pmd,
        int ch, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fputc(ch, fp);
}

 int _RV_fputs(_RV_pmd *str_pmd, _RV_pmd *fp_pmd,
        char *str, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(fp_pmd);
  return fputs(str, fp);
}

 int _RV__IO_getc(_RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return getc(fp);
}

#if !defined __USE_ISOC11 \
    || (defined __cplusplus && __cplusplus <= 201103L)
 char *_RV_gets(_RV_pmd *ret_pmd,
        _RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
#if defined(__GNUC__)
  ret = fgets(str, 1024, stdin);
#else
  ret = gets(str);
#endif

  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, str_pmd);

  _RV_pmd_free_null_ptr(str_pmd);
  return str;
}
#else
 int _RV_gets(
        _RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
#if defined(__GNUC__)
  int ret;
  str = fgets(str, 1024, stdin);
  if(str) ret = strlen(str);
  else ret = 0;
#else
  int ret = gets(str);
#endif

  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return ret;
}
#endif

 int _RV__IO_putc(_RV_pmd *fp_pmd,
        int ch, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return putc(ch, fp);
}

 int _RV_puts(_RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return puts(str);
}

 int _RV_ungetc(_RV_pmd *fp_pmd,
        int ch, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                  file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(fp_pmd);
  return ungetc(ch, fp);
}

 void _RV_perror(_RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  perror(str);
}

 void _RV_stdio_init_code()
{
  _RV_pmd_tbl_update_sa((_RV_ptr_addr)&stdin, _RV_static_sa, stdin, stdin + 1);
  _RV_pmd_tbl_update_sa((_RV_ptr_addr)&stdout, _RV_static_sa, stdout, stdout + 1);
  _RV_pmd_tbl_update_sa((_RV_ptr_addr)&stderr, _RV_static_sa, stderr, stderr + 1);
}

 void _RV_stdio_clear_code()
{
  _RV_pmd_tbl_remove((_RV_ptr_addr)&stdin);
  _RV_pmd_tbl_remove((_RV_ptr_addr)&stdout);
  _RV_pmd_tbl_remove((_RV_ptr_addr)&stderr);
}
/******************************* stdlib.h *************************************/
#include <stdlib.h>

 double _RV_atof(_RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return atof(str);
}

 int _RV_atoi(_RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return atoi(str);
}

 long int _RV_atol(_RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return atol(str);
}

 double _RV_strtod(_RV_pmd *str_pmd, _RV_pmd *endptr_pmd,
        const char *str, char **endptr,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  double tmp;
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  if(endptr)
  _RV_check_dpv(endptr_pmd, endptr, sizeof(char*),
                  file_name, func_name, e_line, e_col, e_name);

  tmp = strtod(str, endptr);

  if(endptr)
    _RV_pmd_tbl_update_pmd((_RV_ptr_addr)endptr, str_pmd);

  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(endptr_pmd);

  return tmp;
}

 long int _RV_strtol(_RV_pmd *str_pmd, _RV_pmd *endptr_pmd,
        const char *str, char **endptr, int base,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  long int tmp;
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  if(endptr)
  _RV_check_dpv(endptr_pmd, endptr, sizeof(char*),
                  file_name, func_name, e_line, e_col, e_name);

  tmp = strtol(str, endptr, base);

  if(endptr)
    _RV_pmd_tbl_update_pmd((_RV_ptr_addr)endptr, str_pmd);

  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(endptr_pmd);

  return tmp;
}

 unsigned long int _RV_strtoul(
        _RV_pmd *str_pmd, _RV_pmd *endptr_pmd,
        const char *str, char **endptr, int base,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  unsigned long int tmp;
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  if(endptr)
  _RV_check_dpv(endptr_pmd, endptr, sizeof(char*),
                  file_name, func_name, e_line, e_col, e_name);

  tmp = strtoul(str, endptr, base);

  if(endptr)
    _RV_pmd_tbl_update_pmd((_RV_ptr_addr)endptr, str_pmd);

  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(endptr_pmd);

  return tmp;
}

 void *_RV_malloc(_RV_pmd *ret_pmd,
        size_t size)
{
  void *ret;
  ret = malloc(size);

#if !defined(_RV_NORANDOM) && defined(_RV_SHOWMALLOC)
  printf("malloc: pointer (addr = %p) points to a new block [%p, %p).\n",
         ret, ret, (char*)ret + size);
#else
#endif

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, NULL, _RV_heap,
                  ret, (char*)ret + size);

  return ret;
}

 void *_RV_calloc(_RV_pmd *ret_pmd,
        size_t n, size_t size)
{
  void *ret;
  ret = calloc(n, size);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, NULL, _RV_heap,
                  ret, (char*)ret + n*size);

  return ret;
}

 void *_RV_realloc(_RV_pmd *ret_pmd, _RV_pmd *ptr_pmd,
        void *ptr, unsigned int newsize,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  char ptr_pmd_freed = 0;
  void *p; _RV_pmd *p_pmd;
  void *ret;
  ret = realloc(ptr, newsize);

  /*Extend the original memory block.*/
  if(ret == ptr)
  {
    _RV_pmd_set_stat (ptr_pmd, _RV_heap);
    _RV_pmd_set_base (ptr_pmd, ret);
    _RV_pmd_set_bound(ptr_pmd, (char*)ret + newsize);
    _RV_pmd_cp_pmd(ret_pmd, ptr_pmd);
  }
  /*Use another memory block.*/
  else
  {
    /* invalidate the status of the freed block. */
    if(ptr_pmd)
    {
      if(_RV_pmd_get_stat(ptr_pmd) == _RV_heap)
        _RV_pmd_set_stat(ptr_pmd, _RV_invalid);
    }

    /* copy all pmds of contained pointer members. */
    /* note that this depends on the bound of ptr_pmd. */
    for(p = ptr; p < _RV_pmd_get_bound(ptr_pmd); p = p + sizeof(void*))
    {
      p_pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)p);
      if(p_pmd)
      {
        _RV_pmd_tbl_update_pmd((_RV_ptr_addr)(ret + (p - ptr)), p_pmd);
#if defined(_RV_use_trie)
        ptr_pmd_freed = 0;
#elif defined(_RV_use_hashtable)
        if(ptr_pmd && ptr_pmd->ptra == p) ptr_pmd_freed = 1; /* DO NOT free it later */
#endif
        _RV_pmd_tbl_remove((_RV_ptr_addr)p);
      }
    }

    /* initialize the status of the allocated block. */
    _RV_pmd_set(ret_pmd, NULL, _RV_heap,
                  ret, (char*)ret + newsize);
  }

  if(!ptr_pmd_freed)
  _RV_pmd_free_null_ptr(ptr_pmd);
  return ret;
}

 void _RV_free(_RV_pmd *ptr_pmd,
        void *ptr,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  char ptr_pmd_freed = 0;
  void *p;
  _RV_status stat = _RV_pmd_get_stat(ptr_pmd);

  /*check pointer validity.*/
  if(ptr == NULL) /* free(NULL) is allowed */
    return;

  /*check temporal errors, incl. object and sub-object.*/
  if(ptr_pmd == NULL)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, p_line, p_col, p_name, ptr);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
  }

  if(stat == _RV_invalid)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "points to an invalid object. "
           "[temporal error][illegal free]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "points to an invalid object (original block is [%p, %p)). "
           "[temporal error][illegal free]\n",
           file_name, p_line, p_col, p_name, ptr, ptr_pmd->base, ptr_pmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
  }

  /*check segment errors.*/
  if(stat != _RV_heap && stat != _RV_library)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "does not point to a heap object. "
           "[segment error][illegal free]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "does not point to a heap object (original block is [%p, %p)). "
           "[segment error][illegal free]\n",
           file_name, p_line, p_col, p_name, ptr, ptr_pmd->base, ptr_pmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
  }

  /*check spatial errors.*/
  if(ptr_pmd && ptr != ptr_pmd->base)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#ifdef _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "is not the base address. "
           "[spatial error][illegal free]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "is not the base address (original block is [%p, %p)). "
           "[spatial error][illegal free]\n",
           file_name, p_line, p_col, p_name, ptr, ptr_pmd->base, ptr_pmd->bound);
#endif
    _RV_error_count++;
    MEMSAFE_ACTION
  }

  free(ptr);

  /* invalidate the status of the freed block. */
  if(ptr_pmd)
  {
    if(_RV_pmd_get_stat(ptr_pmd) == _RV_heap)
      _RV_pmd_set_stat(ptr_pmd, _RV_invalid);
  }

  /* remove all pmds of contained pointer members. */
  /* note that this depends on the bound of ptr_pmd. */
  for(p = ptr; p < _RV_pmd_get_bound(ptr_pmd); p = p + sizeof(void*))
  {
#if defined(_RV_use_trie)
    ptr_pmd_freed = 0;
#elif defined(_RV_use_hashtable)
    if(ptr_pmd && ptr_pmd->ptra == p) ptr_pmd_freed = 1; /* DO NOT free it later */
#endif
    _RV_pmd_tbl_remove((_RV_ptr_addr)p);
  }

  if(!ptr_pmd_freed)
  _RV_pmd_free_null_ptr(ptr_pmd);
}

 int _RV_atexit(_RV_pmd *func_pmd,
        void (*func)(void),
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  _RV_check_dpfv(func_pmd, func,
                   file_name, func_name, f_line, f_col, f_name);
  _RV_pmd_free_null_ptr(func_pmd);
  return atexit(func);
}

 char *_RV_getenv(_RV_pmd *ret_pmd, _RV_pmd *name_pmd,
        const char *name,
        const char *file_name, const char *func_name,
        unsigned n_line, unsigned n_col, const char *n_name)
{
  char *ret;
  _RV_check_dpv(name_pmd, name, _RV_sstrlen(name)+1,
                  file_name, func_name, n_line, n_col, n_name);

  ret = getenv(name);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
                  ret, ret + _RV_sstrlen(ret) + 1);

  _RV_pmd_free_null_ptr(name_pmd);
  return ret;
}

 int _RV_system(_RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return system(str);
}

 int _RV_mblen(_RV_pmd *str_pmd,
        const char *str, size_t n,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return mblen(str, n);
}

 size_t _RV_mbstowcs(_RV_pmd *pwcs_pmd, _RV_pmd *str_pmd,
        wchar_t *pwcs, char *str, size_t n,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(pwcs_pmd, pwcs, sizeof(wchar_t),
                  file_name, func_name, p_line, p_col, p_name);
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(pwcs_pmd);
  _RV_pmd_free_null_ptr(str_pmd);
  return mbstowcs(pwcs, str, n);
}

 int _RV_mbtowc(_RV_pmd *pwc_pmd, _RV_pmd *str_pmd,
        wchar_t *pwc, char *str, size_t n,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(pwc_pmd, pwc, sizeof(wchar_t),
                  file_name, func_name, p_line, p_col, p_name);
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(pwc_pmd);
  _RV_pmd_free_null_ptr(str_pmd);
  return mbtowc(pwc, str, n);
}

 size_t _RV_wcstombs(_RV_pmd *str_pmd, _RV_pmd *pwcs_pmd,
        char *str, wchar_t *pwcs, size_t n,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(pwcs_pmd, pwcs, sizeof(wchar_t),
                  file_name, func_name, p_line, p_col, p_name);
  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(pwcs_pmd);
  return wcstombs(str, pwcs, n);
}

 int _RV_wctomb(_RV_pmd *str_pmd,
        char *str, wchar_t wchar,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str)+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_pmd_free_null_ptr(str_pmd);
  return wctomb(str, wchar);
}

 void *_RV_bsearch(_RV_pmd *ret_pmd,
        _RV_pmd *key_pmd, _RV_pmd *base_pmd, _RV_pmd *compar_pmd,
        void *key, void *base, size_t num, size_t size, __compar_fn_t compar,
        const char *file_name, const char *func_name,
        unsigned k_line, unsigned k_col, const char *k_name,
        unsigned b_line, unsigned b_col, const char *b_name,
        unsigned c_line, unsigned c_col, const char *c_name)
{
  void *ret;
  _RV_check_dpv(key_pmd, key, size,
                  file_name, func_name, k_line, k_col, k_name);
  _RV_check_dpv(base_pmd, base, num*size,
                  file_name, func_name, b_line, b_col, b_name);
  _RV_check_dpfv(compar_pmd, compar,
                   file_name, func_name, c_line, c_col, c_name);

  /*Pass the pmds to the function pointer compar.*/
  _RV_fmd_tbl_create((_RV_func_addr)compar, 2);
  _RV_fmd_tbl_update_pmd((_RV_func_addr)compar, 0, key_pmd);
  _RV_fmd_tbl_update_pmd((_RV_func_addr)compar, 1, base_pmd);
  ret = bsearch(key, base, num, size, compar);
  _RV_fmd_tbl_remove((_RV_func_addr)compar);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, base_pmd);

  _RV_pmd_free_null_ptr(key_pmd);
  _RV_pmd_free_null_ptr(base_pmd);
  _RV_pmd_free_null_ptr(compar_pmd);

  return ret;
}

 void _RV_qsort(
        _RV_pmd *base_pmd, _RV_pmd *compar_pmd,
        void *base, size_t num, size_t size, __compar_fn_t compar,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name,
        unsigned c_line, unsigned c_col, const char *c_name)
{
  _RV_check_dpv(base_pmd, base, num*size,
                  file_name, func_name, b_line, b_col, b_name);
  _RV_check_dpfv(compar_pmd, compar,
                   file_name, func_name, c_line, c_col, c_name);

  /*Pass the pmds to the function pointer compar.*/
  _RV_fmd_tbl_create((_RV_func_addr)compar, 2);
  _RV_fmd_tbl_update_pmd((_RV_func_addr)compar, 0, base_pmd);
  _RV_fmd_tbl_update_pmd((_RV_func_addr)compar, 1, base_pmd);
  qsort(base, num, size, compar);
  _RV_fmd_tbl_remove((_RV_func_addr)compar);

  _RV_pmd_free_null_ptr(base_pmd);
  _RV_pmd_free_null_ptr(compar_pmd);
}
/***************************** string.h ********************************/
#include <string.h>

 void *_RV_memchr(_RV_pmd *ret_pmd, _RV_pmd *src_pmd,
                         const void *src, int c, size_t n,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  _RV_check_dpv(src_pmd, src, n,
                  file_name, func_name, s_line, s_col, s_name);

  ret = memchr(src, c, n);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, src_pmd);

  _RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 int _RV_memcmp(_RV_pmd *str1_pmd, _RV_pmd *str2_pmd,
                       const void *str1, const void *str2, size_t n,
                       const char *file_name, const char *func_name,
                       unsigned s1_line, unsigned s1_col, const char *s1_name,
                       unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  _RV_check_dpv(str1_pmd, str1, n,
                  file_name, func_name, s1_line, s1_col, s1_name);
  _RV_check_dpv(str2_pmd, str2, n,
                  file_name, func_name, s2_line, s2_col, s2_name);

  _RV_pmd_free_null_ptr(str1_pmd);
  _RV_pmd_free_null_ptr(str2_pmd);

  return memcmp(str1, str2, n);
}

 void *_RV_memcpy(_RV_pmd *ret_pmd, _RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                         void *dest, const void *src, size_t n,
                         const char *file_name, const char *func_name,
                         unsigned d_line, unsigned d_col, const char *d_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  void *p;
  _RV_pmd *p_pmd;

  _RV_check_dpv(src_pmd, src, n,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, n,
                  file_name, func_name, d_line, d_col, d_name);

  ret = memcpy(dest, src, n);

  /* copy all pmds of contained pointer members. */
  if(dest < src)
    for(p = (void *)((size_t)src & ~(size_t)7);
        p < src + n; p = p + sizeof(void*))
    {
      if(p < src) continue;
      p_pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)p);
      if(p_pmd)
      {
        _RV_pmd_tbl_update_pmd((_RV_ptr_addr)(dest + (p - src)), p_pmd);
      }
    }
  else if(dest > src)
    for(p = (void *)((size_t)(src + n - 1) & ~(size_t)7);
        p >= src; p = p - sizeof(void*))
    {
      p_pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)p);
      if(p_pmd)
      {
        _RV_pmd_tbl_update_pmd((_RV_ptr_addr)(dest + (p - src)), p_pmd);
      }
    }

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  _RV_pmd_free_null_ptr(src_pmd);
  _RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

#if defined(_RV_c89) || defined(_RV_c90) || defined(_RV_c99) || defined(_RV_c11)
 int _RV_memccpy(_RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                          void *dest, const void *src, int c, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(src_pmd, src, n,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, n,
                  file_name, func_name, d_line, d_col, d_name);

  _RV_pmd_free_null_ptr(src_pmd);
  _RV_pmd_free_null_ptr(dest_pmd);

  return memccpy(dest, src, c, n);
}
#else
 void *_RV_memccpy(_RV_pmd *ret_pmd, _RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                          void *dest, const void *src, int c, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  _RV_check_dpv(src_pmd, src, n,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, n,
                  file_name, func_name, d_line, d_col, d_name);

  ret = memccpy(dest, src, c, n);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  _RV_pmd_free_null_ptr(src_pmd);
  _RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}
#endif

 void *_RV_memmove(_RV_pmd *ret_pmd, _RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                          void *dest, const void *src, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col,  const char *s_name)
{
  void *ret;
  void *p;
  _RV_pmd *p_pmd;

  _RV_check_dpv(src_pmd, src, n,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, n,
                  file_name, func_name, d_line, d_col, d_name);

  ret = memmove(dest, src, n);

  /* copy all pmds of contained pointer members. */
  if(dest < src)
    for(p = (void *)((size_t)src & ~(size_t)7);
        p < src + n; p = p + sizeof(void*))
    {
      if(p < src) continue;
      p_pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)p);
      if(p_pmd)
      {
        _RV_pmd_tbl_update_pmd((_RV_ptr_addr)(dest + (p - src)), p_pmd);
      }
    }
  else if(dest > src)
    for(p = (void *)((size_t)(src + n - 1) & ~(size_t)7);
        p >= src; p = p - sizeof(void*))
    {
      p_pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)p);
      if(p_pmd)
      {
        _RV_pmd_tbl_update_pmd((_RV_ptr_addr)(dest + (p - src)), p_pmd);
      }
    }

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  _RV_pmd_free_null_ptr(src_pmd);
  _RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

 void *_RV_memset(_RV_pmd *ret_pmd, _RV_pmd *str_pmd,
                         void *str, int c, size_t n,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  _RV_check_dpv(str_pmd, str, n,
                  file_name, func_name, s_line, s_col, s_name);

  ret = memset(str, c, n);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, str_pmd);

  _RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

 char *_RV_strcat(_RV_pmd *ret_pmd, _RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                         char *dest, const char *src,
                         const char *file_name, const char *func_name,
                         unsigned d_line, unsigned d_col, const char *d_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  _RV_check_dpv(dest_pmd, dest, _RV_sstrlen(dest) + _RV_sstrlen(src) + 1,
                  file_name, func_name, d_line, d_col, d_name);
  _RV_check_dpv(src_pmd, src, _RV_sstrlen(src) + 1,
                  file_name, func_name, s_line, s_col, s_name);

  ret = strcat(dest, src);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  _RV_pmd_free_null_ptr(dest_pmd);
  _RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 char *_RV_strncat(_RV_pmd *ret_pmd, _RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                          char *dest, const char *src, int n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  int i;
  for(i = 0; i < n; i++)
    if(src[i] == '\0') break;
  _RV_check_dpv(dest_pmd, dest, _RV_sstrlen(dest) + i + 1,
                  file_name, func_name, d_line, d_col, d_name);
  _RV_check_dpv(src_pmd, src, (i == n) ? n : i+1,
                  file_name, func_name, s_line, s_col, s_name);

  ret = strncat(dest, src, n);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  _RV_pmd_free_null_ptr(src_pmd);
  _RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

 char *_RV_strchr(_RV_pmd *ret_pmd, _RV_pmd *src_pmd,
                         const char *src, int c,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  unsigned i;
  for(i = 0; src[i] != '\0'; i++)
    if(src[i] == c) break;
  _RV_check_dpv(src_pmd, src, i + 1,
                  file_name, func_name, s_line, s_col, s_name);

  ret = strchr(src, c);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, src_pmd);

  _RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 int _RV_strcmp(_RV_pmd *str1_pmd, _RV_pmd *str2_pmd,
                       const char *str1, const char *str2,
                       const char *file_name, const char *func_name,
                       unsigned s1_line, unsigned s1_col, const char *s1_name,
                       unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  unsigned i;
  for(i = 0; str1[i] != '\0' && str2[i] != '\0'; i++)
    if(str1[i] != str2[i]) break;
  _RV_check_dpv(str1_pmd, str1, i + 1,
                  file_name, func_name, s1_line, s1_col, s1_name);
  _RV_check_dpv(str2_pmd, str2, i + 1,
                  file_name, func_name, s2_line, s2_col, s2_name);

  _RV_pmd_free_null_ptr(str2_pmd);
  _RV_pmd_free_null_ptr(str1_pmd);
  return strcmp(str1, str2);
}

 int _RV_strncmp(_RV_pmd *str1_pmd, _RV_pmd *str2_pmd,
                        const char *str1, const char *str2, size_t n,
                        const char *file_name, const char *func_name,
                        unsigned s1_line, unsigned s1_col, const char *s1_name,
                        unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  unsigned i;
  for(i = 0; i < n-1; i++)
    if(str1[i] == '\0' || str2[i] == '\0') break;
  _RV_check_dpv(str1_pmd, str1, i+1,
                  file_name, func_name, s1_line, s1_col, s1_name);
  _RV_check_dpv(str2_pmd, str2, i+1,
                  file_name, func_name, s2_line, s2_col, s2_name);

  _RV_pmd_free_null_ptr(str1_pmd);
  _RV_pmd_free_null_ptr(str2_pmd);
  return strncmp(str1, str2, n);
}

 int _RV_strcoll(_RV_pmd *str1_pmd, _RV_pmd *str2_pmd,
                        char *str1, char *str2,
                        const char *file_name, const char *func_name,
                        unsigned s1_line, unsigned s1_col, const char *s1_name,
                        unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  _RV_check_dpv(str1_pmd, str1, _RV_sstrlen(str1) + 1,
                  file_name, func_name, s1_line, s1_col, s1_name);
  _RV_check_dpv(str2_pmd, str2, _RV_sstrlen(str2) + 1,
                  file_name, func_name, s2_line, s2_col, s2_name);

  _RV_pmd_free_null_ptr(str1_pmd);
  _RV_pmd_free_null_ptr(str2_pmd);
  return strcoll(str1, str2);
}

 char *_RV_strcpy(_RV_pmd *ret_pmd, _RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                         char *dest, const char *src,
                         const char *file_name, const char *func_name,
                         unsigned d_line, unsigned d_col, const char *d_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  _RV_check_dpv(src_pmd, src, _RV_sstrlen(src) + 1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, _RV_sstrlen(src) + 1,
                  file_name, func_name, d_line, d_col, d_name);

  ret = strcpy(dest, src);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  _RV_pmd_free_null_ptr(dest_pmd);
  _RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 char *_RV_strncpy(_RV_pmd *ret_pmd, _RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                          char *dest, const char *src, int n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  int i;
  for(i = 0; i < n-1; i++)
    if(src[i] == '\0') break;
  _RV_check_dpv(src_pmd, src, i+1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, n,
                  file_name, func_name, d_line, d_col, d_name);

  ret = strncpy(dest, src, n);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  _RV_pmd_free_null_ptr(src_pmd);
  _RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

 size_t _RV_strcspn(_RV_pmd *str1_pmd, _RV_pmd *str2_pmd,
                           char *str1, char *str2,
                           const char *file_name, const char *func_name,
                           unsigned s1_line, unsigned s1_col, const char *s1_name,
                           unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  _RV_check_dpv(str1_pmd, str1, _RV_sstrlen(str1) + 1,
                  file_name, func_name, s1_line, s1_col, s1_name);
  _RV_check_dpv(str2_pmd, str2, _RV_sstrlen(str2) + 1,
                  file_name, func_name, s2_line, s2_col, s2_name);

  _RV_pmd_free_null_ptr(str1_pmd);
  _RV_pmd_free_null_ptr(str2_pmd);
  return strcspn(str1, str2);
}

 char *_RV_strerror(_RV_pmd *ret_pmd,
                           int errnum)
{
  char *ret;
  ret = strerror(errnum);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
                  ret, ret + _RV_sstrlen(ret) + 1);

  return ret;
}

 size_t _RV_strlen(_RV_pmd *str_pmd,
                          const char *str,
                          const char *file_name, const char *func_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str) + 1,
                  file_name, func_name, s_line, s_col, s_name);

  _RV_pmd_free_null_ptr(str_pmd);
  return strlen(str);
}

 char *_RV_strpbrk(_RV_pmd *ret_pmd, _RV_pmd *str1_pmd, _RV_pmd *str2_pmd,
                          char *str1, char *str2,
                          const char *file_name, const char *func_name,
                          unsigned s1_line, unsigned s1_col, const char *s1_name,
                          unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  char *ret;
  _RV_check_dpv(str1_pmd, str1, _RV_sstrlen(str1) + 1,
                  file_name, func_name, s1_line, s1_col, s1_name);
  _RV_check_dpv(str2_pmd, str2, _RV_sstrlen(str2) + 1,
                  file_name, func_name, s2_line, s2_col, s2_name);

  ret = strpbrk(str1, str2);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, str1_pmd);

  _RV_pmd_free_null_ptr(str2_pmd);
  _RV_pmd_free_null_ptr(str1_pmd);
  return ret;
}

 char *_RV_strrchr(_RV_pmd *ret_pmd, _RV_pmd *str_pmd,
                          char *str, int c,
                          const char *file_name, const char *func_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  _RV_check_dpv(str_pmd, str, _RV_sstrlen(str) + 1,
                  file_name, func_name, s_line, s_col, s_name);

  ret = strrchr(str, c);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, str_pmd);

  _RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

 size_t _RV_strspn(_RV_pmd *str1_pmd, _RV_pmd *str2_pmd,
                          char *str1, char *str2,
                          const char *file_name, const char *func_name,
                          unsigned s_line, unsigned s_col, const char *s_name,
                          unsigned t_line, unsigned t_col, const char *t_name)
{
  _RV_check_dpv(str1_pmd, str1, _RV_sstrlen(str1) + 1,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(str2_pmd, str2, _RV_sstrlen(str2) + 1,
                  file_name, func_name, t_line, t_col, t_name);

  _RV_pmd_free_null_ptr(str1_pmd);
  _RV_pmd_free_null_ptr(str2_pmd);
  return strspn(str1, str2);
}

 char *_RV_strstr(_RV_pmd *ret_pmd, _RV_pmd *haystack_pmd, _RV_pmd *needle_pmd,
                         const char *haystack, const char *needle,
                         const char *file_name, const char *func_name,
                         unsigned h_line, unsigned h_col, const char *h_name,
                         unsigned n_line, unsigned n_col, const char *n_name)
{
  char *ret;
  _RV_check_dpv(haystack_pmd, haystack, _RV_sstrlen(haystack) + 1,
                  file_name, func_name, h_line, h_col, h_name);
  _RV_check_dpv(needle_pmd, needle, _RV_sstrlen(needle) + 1,
                  file_name, func_name, n_line, n_col, n_name);

  ret = strstr(haystack, needle);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, haystack_pmd);

  _RV_pmd_free_null_ptr(haystack_pmd);
  _RV_pmd_free_null_ptr(needle_pmd);
  return ret;
}

 char *_RV_strtok(_RV_pmd *ret_pmd, _RV_pmd *str_pmd, _RV_pmd *delim_pmd,
                         char *str, const char *delim,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name,
                         unsigned d_line, unsigned d_col, const char *d_name)
{
  /* Remember the pmd of the last non-null str */
  static _RV_pmd pmd = _RV_pmd_init_val;
  char *ret;
  if(str)
  {
    /* Remember the pmd of the last non-null str */
    _RV_pmd_cp_pmd(&pmd, str_pmd);
    _RV_check_dpv(str_pmd, str, _RV_sstrlen(str) + 1,
                    file_name, func_name, s_line, s_col, s_name);
  }
  _RV_check_dpv(delim_pmd, delim, _RV_sstrlen(delim) + 1,
                  file_name, func_name, d_line, d_col, d_name);

  ret = strtok(str, delim);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, &pmd);

  _RV_pmd_free_null_ptr(delim_pmd);
  _RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

 size_t _RV_strxfrm(_RV_pmd *dest_pmd, _RV_pmd *src_pmd,
                           char *dest, char *src, size_t n,
                           const char *file_name, const char *func_name,
                           unsigned d_line, unsigned d_col, const char *d_name,
                           unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(src_pmd, src, n,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, n,
                  file_name, func_name, d_line, d_col, d_name);

  _RV_pmd_free_null_ptr(src_pmd);
  _RV_pmd_free_null_ptr(dest_pmd);
  return strxfrm(dest, src, n);
}

 void _RV_bzero(_RV_pmd *s_pmd,
                       void *s, int n,
                       const char *file_name, const char *func_name,
                       unsigned s_line, unsigned s_col, const char *s_name)
{
  _RV_check_dpv(s_pmd, s, n,
                  file_name, func_name, s_line, s_col, s_name);

  _RV_pmd_free_null_ptr(s_pmd);
  bzero(s, n);
}

 void _RV_bcopy(_RV_pmd *src_pmd, _RV_pmd *dest_pmd,
                       void *src, void *dest, int n,
                       const char *file_name, const char *func_name,
                       unsigned s_line, unsigned s_col, const char *s_name,
                       unsigned d_line, unsigned d_col, const char *d_name)
{
  void *p;
  _RV_pmd *p_pmd;

  _RV_check_dpv(src_pmd, src, n,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(dest_pmd, dest, n,
                  file_name, func_name, d_line, d_col, d_name);

  /* copy all pmds of contained pointer members. */
  if(dest < src)
    for(p = (void *)((size_t)src & ~(size_t)7);
        p < src + n; p = p + sizeof(void*))
    {
      if(p < src) continue;
      p_pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)p);
      if(p_pmd)
      {
        _RV_pmd_tbl_update_pmd((_RV_ptr_addr)(dest + (p - src)), p_pmd);
      }
    }
  else if(dest > src)
    for(p = (void *)((size_t)(src + n - 1) & ~(size_t)7);
        p >= src; p = p - sizeof(void*))
    {
      p_pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)p);
      if(p_pmd)
      {
        _RV_pmd_tbl_update_pmd((_RV_ptr_addr)(dest + (p - src)), p_pmd);
      }
    }

  _RV_pmd_free_null_ptr(dest_pmd);
  _RV_pmd_free_null_ptr(src_pmd);
  bcopy(src, dest, n);
}
/***************************** time.h ********************************/
#include <time.h>

 char *_RV_asctime(_RV_pmd *ret_pmd,
        _RV_pmd *timeptr_pmd,
        struct tm *timeptr,
        const char *file_name, const char *func_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  char *ret;
  _RV_check_dpv(timeptr_pmd, timeptr, sizeof(struct tm),
                  file_name, func_name, t_line, t_col, t_name);

  ret = asctime(timeptr);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
                  ret, ret + _RV_sstrlen(ret) + 1);

  _RV_pmd_free_null_ptr(timeptr_pmd);
  return ret;
}

 char *_RV_ctime(_RV_pmd *ret_pmd,
        _RV_pmd *timeptr_pmd,
        time_t *timeptr,
        const char *file_name, const char *func_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  char *ret;
  _RV_check_dpv(timeptr_pmd, timeptr, sizeof(time_t),
                  file_name, func_name, t_line, t_col, t_name);

  ret = ctime(timeptr);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid,
                  ret, ret + _RV_sstrlen(ret) + 1);

  _RV_pmd_free_null_ptr(timeptr_pmd);
  return ret;
}

 struct tm *_RV_gmtime(_RV_pmd *ret_pmd,
        _RV_pmd *timeptr_pmd,
        time_t *timeptr,
        const char *file_name, const char *func_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  struct tm *ret;
  _RV_check_dpv(timeptr_pmd, timeptr, sizeof(time_t),
                  file_name, func_name, t_line, t_col, t_name);

  ret = gmtime(timeptr);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid, ret, ret + 1);

  _RV_pmd_free_null_ptr(timeptr_pmd);
  return ret;
}

 struct tm *_RV_localtime(_RV_pmd *ret_pmd,
        _RV_pmd *timeptr_pmd,
        time_t *timeptr,
        const char *file_name, const char *func_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  struct tm *ret;
  _RV_check_dpv(timeptr_pmd, timeptr, sizeof(time_t),
                  file_name, func_name, t_line, t_col, t_name);

  ret = localtime(timeptr);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid, ret, ret + 1);

  _RV_pmd_free_null_ptr(timeptr_pmd);
  return ret;
}

 time_t _RV_mktime(_RV_pmd *timeptr_pmd,
        struct tm *timeptr,
        const char *file_name, const char *func_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  _RV_check_dpv(timeptr_pmd, timeptr, sizeof(struct tm),
                  file_name, func_name, t_line, t_col, t_name);
  _RV_pmd_free_null_ptr(timeptr_pmd);
  return mktime(timeptr);
}

 size_t _RV_strftime(
        _RV_pmd *str_pmd, _RV_pmd *format_pmd, _RV_pmd *timeptr_pmd,
        char *str, size_t maxsize, char *format, struct tm *timeptr,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  _RV_check_dpv(str_pmd, str, maxsize,
                  file_name, func_name, s_line, s_col, s_name);
  _RV_check_dpv(format_pmd, format, _RV_sstrlen(format)+1,
                  file_name, func_name, f_line, f_col, f_name);
  _RV_check_dpv(timeptr_pmd, timeptr, sizeof(struct tm),
                  file_name, func_name, t_line, t_col, t_name);

  _RV_pmd_free_null_ptr(str_pmd);
  _RV_pmd_free_null_ptr(format_pmd);
  _RV_pmd_free_null_ptr(timeptr_pmd);

  return strftime(str, maxsize, format, timeptr);
}

 time_t _RV_time(_RV_pmd *timeptr_pmd,
        time_t *timeptr,
        const char *file_name, const char *func_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  if(timeptr != NULL)
    _RV_check_dpv(timeptr_pmd, timeptr, sizeof(time_t),
                    file_name, func_name, t_line, t_col, t_name);
  _RV_pmd_free_null_ptr(timeptr_pmd);
  return time(timeptr);
}

int *__errno_location();

 int *_RV___errno_location(_RV_pmd *ret_pmd)
{
  int *ret;
  ret = __errno_location();

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_set(ret_pmd, _RV_global_sa, _RV_invalid, ret, ret + 1);
  return ret;
}
/***************************** sys/times.h ********************************/
#include <sys/times.h>

/*
struct tms
  {
    clock_t tms_utime ;
    clock_t tms_stime ;

    clock_t tms_cutime ;
    clock_t tms_cstime ;
  };
*/

 clock_t _RV_times(_RV_pmd *buf_pmd,
        struct tms *buf,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  if(buf != NULL)
    _RV_check_dpv(buf_pmd, buf, sizeof(struct tms),
                    file_name, func_name, b_line, b_col, b_name);
  _RV_pmd_free_null_ptr(buf_pmd);
  return times(buf);
}
/***************************** unistd.h ********************************/
#include <unistd.h>

 ssize_t _RV_read(_RV_pmd *buf_pmd,
        int fd, void *buf, size_t nbytes,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  _RV_check_dpv(buf_pmd, buf, nbytes,
                  file_name, func_name, b_line, b_col, b_name);
  _RV_pmd_free_null_ptr(buf_pmd);
  return read(fd, buf, nbytes);
}

 ssize_t _RV_write(_RV_pmd *buf_pmd,
        int fd, void *buf, size_t nbytes,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  _RV_check_dpv(buf_pmd, buf, nbytes,
                  file_name, func_name, b_line, b_col, b_name);
  _RV_pmd_free_null_ptr(buf_pmd);
  return write(fd, buf, nbytes);
}

 int _RV_unlink(_RV_pmd *path_pmd,
        const char *path,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  _RV_check_dpv(path_pmd, path, _RV_sstrlen(path) + 1,
                  file_name, func_name, p_line, p_col, p_name);
  _RV_pmd_free_null_ptr(path_pmd);
  return unlink(path);
}

 char *_RV_getcwd(_RV_pmd *ret_pmd, _RV_pmd *buf_pmd,
        char *buf, size_t size,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  char *ret;
  _RV_check_dpv(buf_pmd, buf, size,
                  file_name, func_name, b_line, b_col, b_name);

  ret = getcwd(buf, size);

  if(ret == NULL)
    _RV_pmd_set_null(ret_pmd);
  else
    _RV_pmd_cp_pmd(ret_pmd, buf_pmd);

  _RV_pmd_free_null_ptr(buf_pmd);
  return ret;
}

#if _POSIX_C_SOURCE >= 2
extern char *optarg;
extern int optind, opterr, optopt;
 int _RV_getopt(_RV_pmd *argv_pmd, _RV_pmd *options_pmd,
        int argc, char *const *argv, const char *options,
        const char *file_name, const char *func_name,
        unsigned a_line, unsigned a_col, const char *a_name,
        unsigned o_line, unsigned o_col, const char *o_name)
{
  int ret, i; _RV_pmd *pmd;
  _RV_check_dpv(options_pmd, options, _RV_sstrlen(options) + 1,
                  file_name, func_name, o_line, o_col, o_name);

  ret = getopt(argc, argv, options);

  if(optarg == NULL)
    _RV_pmd_tbl_remove((_RV_ptr_addr)&optarg);
  else
  {
    for(i = 0; i < argc; i++)
    {
      pmd = _RV_pmd_tbl_lookup((_RV_ptr_addr)&argv[i]);
      if(_RV_pmd_get_base(pmd) <= (void*)optarg &&
         (void*)optarg < _RV_pmd_get_bound(pmd))
        _RV_pmd_tbl_update_ptr((_RV_ptr_addr)&optarg, (_RV_ptr_addr)&argv[i]);
    }
  }

  _RV_pmd_free_null_ptr(argv_pmd);
  _RV_pmd_free_null_ptr(options_pmd);
  return ret;
}
#endif
/********************************* utime.h ************************************/
#include <utime.h>

 int _RV_utime(_RV_pmd *path_pmd, _RV_pmd *times_pmd,
        char *path, struct utimbuf *times,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  _RV_check_dpv(path_pmd, path, _RV_sstrlen(path)+1,
                  file_name, func_name, p_line, p_col, p_name);
  if(times != NULL)
    _RV_check_dpv(times_pmd, times, sizeof(struct utimbuf),
                    file_name, func_name, t_line, t_col, t_name);
  _RV_pmd_free_null_ptr(path_pmd);
  _RV_pmd_free_null_ptr(times_pmd);
  return utime(path, times);
}
/******************************* call by ptr **********************************/

 void _RV_call_wrapper_by_ptr(void (*fp)(), ...)
{
  va_list vl;
  va_start(vl,fp);

  /* stdlib.h */
  if(fp == (void (*)())malloc)
  {
    void **ret_addr = va_arg(vl, void **);
    _RV_pmd *ret_pmd = va_arg(vl, _RV_pmd *);
    size_t size = va_arg(vl, size_t);
    va_end(vl);

    *ret_addr = _RV_malloc(ret_pmd, size);
    return;
  }

  if(fp == (void (*)())realloc)
  {
    void **ret_addr = va_arg(vl, void **);
    _RV_pmd *ret_pmd = va_arg(vl, _RV_pmd *);
    _RV_pmd *ptr_pmd = va_arg(vl, _RV_pmd *);
    void *ptr = va_arg(vl, void *);
    unsigned int newsize = va_arg(vl, unsigned int);
    char *file_name = va_arg(vl, char *);
    char *func_name = va_arg(vl, char *);
    unsigned p_line = va_arg(vl, unsigned);
    unsigned p_col = va_arg(vl, unsigned);
    char *p_name = va_arg(vl, char *);
    va_end(vl);

    *ret_addr = _RV_realloc(ret_pmd, ptr_pmd, ptr, newsize, file_name, func_name, p_line, p_col, p_name);
    return;
  }

  if(fp == (void (*)())free)
  {
    _RV_pmd *ptr_pmd = va_arg(vl, _RV_pmd *);
    void *ptr = va_arg(vl, void *);
    char *file_name = va_arg(vl, char *);
    char *func_name = va_arg(vl, char *);
    unsigned p_line = va_arg(vl, unsigned);
    unsigned p_col = va_arg(vl, unsigned);
    char *p_name = va_arg(vl, char *);
    va_end(vl);

    _RV_free(ptr_pmd, ptr, file_name, func_name, p_line, p_col, p_name);
    return;
  }

  /* string.h */
  if(fp == (void (*)())memcpy)
  {
    void **ret_addr = va_arg(vl, void **);
    _RV_pmd *ret_pmd = va_arg(vl, _RV_pmd *);
    _RV_pmd *dest_pmd = va_arg(vl, _RV_pmd *);
    _RV_pmd *src_pmd = va_arg(vl, _RV_pmd *);
    void *dest = va_arg(vl, void *);
    const void *src = va_arg(vl, const void *);
    size_t n = va_arg(vl, size_t);
    const char *file_name = va_arg(vl, const char *);
    const char *func_name = va_arg(vl, const char *);
    unsigned d_line = va_arg(vl, unsigned);
    unsigned d_col = va_arg(vl, unsigned);
    const char *d_name = va_arg(vl, const char *);
    unsigned s_line = va_arg(vl, unsigned);
    unsigned s_col = va_arg(vl, unsigned);
    const char *s_name = va_arg(vl, const char *);
    va_end(vl);

    *ret_addr = _RV_memcpy(ret_pmd, dest_pmd, src_pmd, dest, src, n,
                  file_name, func_name, d_line, d_col, d_name, s_line, s_col, s_name);
    return;
  }

  /* unhandled call wrapper by pointer */
  fprintf(stderr, "error: unhandled call wrapper by pointer %p.\n", fp);
  abort();
}

int _RV_has_wrapper(void (*fp)())
{
  if(// fp == (void (*)())_IO_getc ||
     // fp == (void (*)())_IO_putc ||
     fp == (void (*)())__ctype_b_loc ||
     fp == (void (*)())__errno_location ||
     fp == (void (*)())asctime ||
     fp == (void (*)())atexit ||
     fp == (void (*)())atof ||
     fp == (void (*)())atoi ||
     fp == (void (*)())atol ||
     fp == (void (*)())bsearch ||
     fp == (void (*)())calloc ||
     fp == (void (*)())clearerr ||
     fp == (void (*)())ctime ||
     fp == (void (*)())fclose ||
     fp == (void (*)())feof ||
     fp == (void (*)())ferror ||
     fp == (void (*)())fflush ||
     fp == (void (*)())fgetc ||
     fp == (void (*)())fgetpos ||
     fp == (void (*)())fgets ||
     fp == (void (*)())fopen ||
     fp == (void (*)())fprintf ||
     fp == (void (*)())fputc ||
     fp == (void (*)())fputs ||
     fp == (void (*)())fread ||
     fp == (void (*)())free ||
     fp == (void (*)())freopen ||
     fp == (void (*)())frexp ||
     fp == (void (*)())fscanf ||
     fp == (void (*)())fseek ||
     fp == (void (*)())fsetpos ||
     fp == (void (*)())fstat ||
     fp == (void (*)())ftell ||
     fp == (void (*)())fwrite ||
     fp == (void (*)())getc ||
     fp == (void (*)())getcwd ||
     fp == (void (*)())getenv ||
     fp == (void (*)())getpwnam ||
     fp == (void (*)())getpwuid ||
     fp == (void (*)())gmtime ||
     fp == (void (*)())localeconv ||
     fp == (void (*)())localtime ||
     fp == (void (*)())longjmp ||
     fp == (void (*)())malloc ||
     fp == (void (*)())mblen ||
     fp == (void (*)())mbstowcs ||
     fp == (void (*)())mbtowc ||
     fp == (void (*)())memchr ||
     fp == (void (*)())memcmp ||
     fp == (void (*)())memcpy ||
     fp == (void (*)())memmove ||
     fp == (void (*)())memset ||
     fp == (void (*)())mktime ||
     fp == (void (*)())modf ||
     fp == (void (*)())perror ||
     fp == (void (*)())printf ||
     fp == (void (*)())putc ||
     fp == (void (*)())puts ||
     fp == (void (*)())qsort ||
     fp == (void (*)())read ||
     fp == (void (*)())realloc ||
     fp == (void (*)())remove ||
     fp == (void (*)())rename ||
     fp == (void (*)())rewind ||
     fp == (void (*)())scanf ||
     fp == (void (*)())setbuf ||
     fp == (void (*)())setlocale ||
     fp == (void (*)())setvbuf ||
     fp == (void (*)())signal ||
     fp == (void (*)())sprintf ||
     fp == (void (*)())sscanf ||
     fp == (void (*)())strcat ||
     fp == (void (*)())strchr ||
     fp == (void (*)())strcmp ||
     fp == (void (*)())strcoll ||
     fp == (void (*)())strcpy ||
     fp == (void (*)())strcspn ||
     fp == (void (*)())strerror ||
     fp == (void (*)())strftime ||
     fp == (void (*)())strlen ||
     fp == (void (*)())strncat ||
     fp == (void (*)())strncmp ||
     fp == (void (*)())strncpy ||
     fp == (void (*)())strpbrk ||
     fp == (void (*)())strrchr ||
     fp == (void (*)())strspn ||
     fp == (void (*)())strstr ||
     fp == (void (*)())strtod ||
     fp == (void (*)())strtok ||
     fp == (void (*)())strtol ||
     fp == (void (*)())strtoul ||
     fp == (void (*)())strxfrm ||
     fp == (void (*)())system ||
     fp == (void (*)())time ||
     fp == (void (*)())times ||
     fp == (void (*)())tmpfile ||
     fp == (void (*)())ungetc ||
     fp == (void (*)())unlink ||
     fp == (void (*)())utime ||
     fp == (void (*)())vfprintf ||
     fp == (void (*)())vprintf ||
     fp == (void (*)())vsprintf ||
     fp == (void (*)())wcstombs ||
     fp == (void (*)())wctomb ||
     fp == (void (*)())write)
    return 1;
  return 0;
}

void _RV_clear_pmd_41461360_3745();

void _RV_global_init_code() {
  _RV_function_sa = _RV_stat_node_create(_RV_function, 1);
  _RV_global_sa = _RV_stat_node_create(_RV_global, 1);
  _RV_static_sa = _RV_stat_node_create(_RV_static, 1);
  _RV_library_sa = _RV_stat_node_create(_RV_library, 1);
  _RV_stdio_init_code();

}

void _RV_global_clear_code() {
// _RV_clear_pmd_41461360_3745();

  _RV_stdio_clear_code();
  _RV_stat_node_dec(_RV_function_sa);
  _RV_stat_node_dec(_RV_global_sa);
  _RV_stat_node_dec(_RV_static_sa);
  _RV_stat_node_dec(_RV_library_sa);
}

